I've noticed a pattern for all the Lua Glue I'm generating.  Here's the 
algorithm I'm using by hand:

Take a Class or Type you wish to wrap-
	Make a new publicly viewable class for the Glue.
	
	METATABLENAME = a string with the namespaces and the class name
	GLOBALTABLENAME = the same thing
	
	Generate a function which creates a managed pointer of some kind for the 
		class, such as a boost smart pointer of some kind.  Then place this on
		the stack as a thick Lua user data (not a thin one, which is just a
		pointer- this enforces Lua to kill the data).
	Make a public method that can take an instance of the object and place it
		onto the Lua stack with the associated meta data.  Other LuaGlue methods
		for other wrapped classes should be able to call this so they can put
		instances of the class being wrapped on the stack themselves, say if
		they need to return a value.
	Make another public method that will "Open" this type in Lua, that can be
		called by the "require" keyword.
		
	Create a series of functions that will be registered to the global table in
		Lua for this type.  There will be one for each public static object.
		
	Also create a series of functions that will be registered to the meta table,
		but these will point to the built in Lua functions such as __gc.  But
		for "index", make a special method that will return the value for other
		methods and make one method for each instance method in the class being
		wrapped.  These methdos are just like the static method, but they always
		expect the first value to be a user data with the metatable named
		METATABLENAME, and they get a reference to that table.
		
	Methods for both static and instance methods share the following:
		They look for arguments on the stack in the same order as the methods
		list those arguments.  They use the Lua API functions to get ints,
		strings etc, but for objects they check to see if a LuaGlue type exists
		that they can call to wrap the function.  The default is that such
		classes are presumed to exist, and are included in the CPP file and 
		called optimisitically to get the needed references off the stack.
		
		Then a call is made to the method being wrapped directly.
		
		The return value, if not a primitive, is wrapped using some external
		glue function.
		

Now, what about such properties as "Members" on the Scope lua glue object?
Well you see, the above is only the first way to wrap a LuaGlue object.
You can also make one by defining a custom Lua glue object.  For Scope, it would
be like this- you tell Lua that the GetMembers and GetMemberSize functions are
omitted from Lua.  Then you create a special object, inside the Scope def, like
so:

	/*~ Lua collection MemberCollection
		{
			__index = GetMember
			__len	= GetMemberCount
			__string = GetMemberCount	    
		}
	 */

The name comes from "MemberCollection".  When it reads "index" it knows, because 
it can use Macaroni's rich knowledge of the type, that GetMember accepts an
integer and therefore the return value of this is what is returned and the 
__index method must only accept integers.
It also knows that __len is the return value of GetMemberCount().  It uses this
as a guard to throw lua errors if the collection is accessed erroneously.
__string is obtained by creating a string stream and returning the output value
of the GetMemberCount.

Then, in the class def, you add a special Lua property like so:

/*~Lua new property Members returns MemberCollection */


