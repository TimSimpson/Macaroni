2009-05-17

THE PROBLEM:
I unfortunately have discovered how impossible it will be to create the Model
as I parse the Macaroni Document.  The trouble is I'll often have to create
an object I know nothing about.

For example, lets say I see the line "namespace A { B::C::D::E field; }".  I 
can guess based on the Context that field is a type, but I have no idea if its
a primitive type or a Class.  Lets say I guessed all such things are classes-
that's fine, but how do I know that C and D aren't both nested classes the later
or which contains E?

I've tried very hard to accomodate this but it just seems intractable without
making a mess.

PROPOSED SOLUTION:
Offer a "lose" type.  This blob class could contain just about everything, but
its really just a guess at what the member or type could be.  Model::Prototype?

Also, this class would need to have a series of members where the Parser could
include details on why it thinks a given way for a Type.

There would be two constants I know for sure:
A Prototype has a name, and a parent.  It may also have members.

Might be a type- the reasons for this should be included 


class Source-
	A location the Macaroni parser reads from, such as a File.
class SourceLocation-
	Essentially, a line number coupled with a Source.
class Concept-
class Rule-
	This is a collection of numbers, each relating to why the parser
	believes a certain concept.
class Evidence- or Axiom or Postulate
	A combined SourceLocation with Rule to state some fact about the prototype.

class Reasoning- 
	A collection of Postulates.

A Prototype is then a collection of Concepts.  Each Concept has a list of 
	Evidence objects and a IsTrue() method.

NodeLocation-
	

Prototype members-
	Reasoning IsType();		
	Reasoning IsClass();
		PrototypeClassInfo * classInfo; // Contains details such as BaseClasses
										// and such, which point to Prototypes.
	Reasoning IsFunction();
	Reasoning IsField();
	Reasoning HasCodeBody();				// Functions would have this.
	Reasoning WasLeftOpen();
	
After parsing, this information is then iterated into types in Macaroni::Model.


I could call this a PrototypeMember, and mix it in with the Model hierarchy...
the big win there would be that it could point to Model objects.

But I could still figure out a way to dump new Models into the Model hierarchy.
I could just read this in again.


So the way it would work is that first I'd create a Context, from which I'd
get a Namespace.  Then from there I could use factory methods to create
every other type, and the associations would be strong.  It would be impossible
to create anything loose or by using a Complex name.  It would all be set in 
stone.
