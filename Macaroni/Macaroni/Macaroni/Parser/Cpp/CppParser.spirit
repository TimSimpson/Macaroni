#ifndef MACARONI_PARSER_CPP_CPPPARSER_SPIRIT
#define MACARONI_PARSER_CPP_CPPPARSER_SPIRIT

#include "General.spirit"
#include "CppAxiom.h"
#include "CppAxioms.h"
#include "CppParserState.h"
#include "../../Model/Axiom.h"
#include "../../Model/Cpp/Namespace.h"
#include "../../Model/Node.h"
#include <iostream>
#include "../ParserException.h"
#include "../../Model/Reason.h"


using Macaroni::Parser::Cpp::CppParserState;
using Macaroni::Model::Cpp::Namespace;
using Macaroni::Model::Cpp::NamespacePtr;
using Macaroni::Model::Node;
using Macaroni::Model::NodePtr;
using Macaroni::Model::Reason;
using Macaroni::Model::ReasonPtr;

//#include "Class.h"
//#include "Namespace.h"

// This is a C++ doc that defines a spirit parser and should be included
// from another CPP doc only.

BEGIN_NAMESPACE(Macaroni, Parser, Cpp)

#define BEGIN_ACTOR(actor_type_name)	class actor_type_name \
						{ \
						public: \
							actor_type_name(CppParserState & s) \
							: self(s) \
							{} \
							template <typename IteratorT> void operator()( IteratorT begin, IteratorT end) const {
							
/*#define END_ACTOR(actor_instance_name)	\
							} \
						private:			\							
							CppParserState & self; \
						} actor_instance_name;		*/
	
#define END_ACTOR(actor_instance_name)	} private: CppParserState & self; } actor_instance_name;

#define INIT_ACTOR(actor_instance_name)	actor_instance_name (state)


class ParserActions
{
private:
	//CppParserState & self;
public:
	ParserActions(CppParserState & state)
	 :
#pragma warning(disable : 4355)	 
	 INIT_ACTOR(baseClassAccessKeyword),
	 INIT_ACTOR(baseClassAddition),
	 INIT_ACTOR(classBegin),
	 INIT_ACTOR(classBody),	 
	 INIT_ACTOR(debug),	 
	 INIT_ACTOR(docComment),
	 INIT_ACTOR(importBegin),
	 INIT_ACTOR(importEnd),
	 INIT_ACTOR(namespaceBegin),
	 INIT_ACTOR(namespaceEnd),
	 INIT_ACTOR(namespaceName),
	 INIT_ACTOR(nullAction)
	{
	}
	~ParserActions()
	{}
		
	BEGIN_ACTOR(docComment_)
		/////model.comments.push_back(std::string(pbegin, pend-pbegin));	
	END_ACTOR(docComment)
	
	BEGIN_ACTOR(baseClassAccessKeyword_)
		//self.currentBaseClassAccessKeyword = std::string(pbegin, pend-pbegin);
	END_ACTOR(baseClassAccessKeyword)
	
	BEGIN_ACTOR(baseClassAddition_)
		/*ClassPtr baseClass = Class::FindOrCreate(
				self.currentNamespace, std::string(pbegin, pend-pbegin));
		BaseClass::Access access;
		if (self.currentBaseClassAccessKeyword == "public")
		{
			access = BaseClass::Public;
		}
		else if (self.currentBaseClassAccessKeyword == "protected")
		{
			access = BaseClass::Protected;
		}
		else
		{
			access = BaseClass::Private;
		}
		BaseClassPtr baseClassPtr(new BaseClass(access, baseClass));
		self.currentClass->AddBaseClass(baseClassPtr);
		*/
	END_ACTOR(baseClassAddition)
	
	BEGIN_ACTOR(classBegin_)
		//std::string name = std::string(pbegin, pend-pbegin);		
		//self.currentClass = ClassPtr(Class::FindOrCreate(self.currentNamespace, name));		
	END_ACTOR(classBegin)
	
	BEGIN_ACTOR(classBody_)
		/*if (self.currentClass == false)
		{
			throw new ParserException("Did not expect class body.");
		}
		self.currentClass->SetBody(std::string(pbegin, pend-pbegin));
		
		model.classes.push_back(self.currentClass);
		self.currentClass = ClassPtr();
		*/
	END_ACTOR(classBody)	
	
	BEGIN_ACTOR(debug_)
		//std::cout << "DEBUG:" << std::string(pbegin, pend-pbegin) << std::endl;
	END_ACTOR(debug)
	
	BEGIN_ACTOR(importBegin_)
		//std::string importName = std::string(pbegin, pend-pbegin);
		//self.currentImport = ImportPtr(new Import(self.currentNamespace, importName));		
	END_ACTOR(importBegin)
	
	BEGIN_ACTOR(importEnd_)
		//model.imports.push_back(self.currentImport);		
	END_ACTOR(importEnd)
	
	BEGIN_ACTOR(nullAction_)
		// Do nothing.
	END_ACTOR(nullAction)
	
	BEGIN_ACTOR(namespaceBegin_)
		//MARIO NodePtr node = self.currentScope->FindOrCreate(self.currentNamespaceName);		
		//MARIO ReasonPtr reason = Reason::Create(
		//MARIO 	CppAxioms::NamespaceCreation(), self.GetCurrentSource());
		//MARIO if (node->GetMember() == false || node->GetMember()->GetTypeName() != "Namespace")
		//MARIO {
		//MARIO 	NamespacePtr newNs = Namespace::Create(node, reason);		
		//MARIO }
		//MARIO self.currentScope = node;
		/*NamespacePtr oldNs = self.currentNamespace;		
		
		NamespacePtr ns = self.currentNamespace->FindOrCreateNamespace(self.currentNamespaceName);
				//Namespace::FindOrCreate(
				//self.currentNamespace, self.currentNamespaceName);
		self.currentNamespace = ns;		
		//self.currentNamespace->name = self.currentNamespaceName;		
		//if (oldNs != false)
		//{
		//	self.currentNamespace->parent = oldNs;
		//}
		//self.namespaceStack.push_back(self.currentNamespace);*/
	END_ACTOR(namespaceBegin)
	
	BEGIN_ACTOR(namespaceEnd_)	
		//MARIO self.currentScope = self.currentScope->GetNode();
		/*model.addNamespace(self.currentNamespace);
		
		self.namespaceStack.pop_back();
		if (self.namespaceStack.size() > 0)
		{
			self.currentNamespace = self.namespaceStack.back();
		}
		else
		{
			self.currentNamespace = NamespacePtr();
		}*/
	END_ACTOR(namespaceEnd)
	
	BEGIN_ACTOR(namespaceName_)
		begin.get_position().p();
		//MARIO self.currentNamespaceName = std::string(begin.next_char(), end.base()-begin.base());
	END_ACTOR(namespaceName)
};

class actor_string
{
public:
    actor_string(std::string & rstr) :
        matched(rstr)
    {
    }

    void operator() (const char *pbegin, const char *pend) const
    {
        matched += std::string(pbegin, pend-pbegin);
    }

private:
    std::string & matched;
};



struct DocumentGrammar : public grammar<DocumentGrammar>
{
	ParserActions * actors;
	
    template <typename ScannerT>
    struct definition : General<ScannerT>
    {	
		const std::string * pee;
		
        definition(DocumentGrammar const& self)
        {		
			MACARONI_ASSERT(self.actors != nullptr, "Actors not set on Parser.");
			ParserActions & actors = dynamic_cast<ParserActions &>(*self.actors);
			
			classBegin
				=	General::classKeyword[actors.nullAction]
					>>
					General::complexIdentifier[actors.classBegin]
					>> 
					*
					(
					General::colon[actors.nullAction]
					>>
					General::accessKeyword[actors.baseClassAccessKeyword]
					>>
					General::complexIdentifier[actors.baseClassAddition]					
					)[actors.nullAction]
					>>
					General::braceL[actors.nullAction];			
			/*classRule
				=	General::classKeyword[actors.nullAction]
					>>
					General::complexIdentifier[actors.classBegin]
					>> 
					*
					(
					General::colon[actors.debug]
					>>
					General::accessKeyword[actors.baseClassAccessKeyword]
					>>
					General::complexIdentifier[actors.debug]					
					)[actors.debug]
					>>
					General::braceSandwhich[actors.classBody];			*/
			classFiller
				=	*
					(
					General::commentBlock[actors.docComment]
					|
					method
					);
			classRule
				=	classBegin
					>>
					classFiller
					>>
					General::braceR[actors.classBody];
			importRule
				=	General::importKeyword[actors.nullAction]
					>>
					General::complexIdentifier[actors.importBegin]
					>>
					General::semicolon[actors.importEnd];
			method
				=	(!(General::accessKeyword[actors.debug]))
					>>
					General::complexIdentifier[actors.nullAction]
					>>
					General::cppIdentifier[actors.nullAction]
					>>
					ch_p('(')
					>>
					ch_p(')')
					>>
					General::braceSandwhich[actors.nullAction];
			namespaceFiller
				=	*
					(
					General::commentBlock[actors.docComment]
					|
					importRule
					|
					classRule
					|
					namespaceRule
					);//[*(self.actors->comment)];			
			namespaceBegin
				=	General::namespaceKeyword
					>>
					General::complexIdentifier[actors.namespaceName]
					>>
					General::braceL[actors.nullAction]; // won't work without this action(?)
			namespaceRule
				=	namespaceBegin[actors.namespaceBegin]
					>>
					namespaceFiller
					>>
					General::braceR[actors.namespaceEnd];
			/** The definition of a Macaroni program. */
			program
				=	namespaceFiller;
        }

        rule<ScannerT> 
			classBegin,
			classFiller,
			classRule, 
			importRule,
			method,
			namespaceBegin, namespaceFiller,
			namespaceRule, program;

        rule<ScannerT> const&
        start() const { return program; }
    };
};

END_NAMESPACE

#endif