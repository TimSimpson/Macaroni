require "Macaroni.IO.GeneratedFileWriter";
require "Macaroni.Model.Library";
require "Macaroni.IO.Path";
--require "Macaroni.IO.PathList";


function Build(library, sources, outputPath, installPath, extraArgs)
	local excludePattern;
	if (extraArgs == nil or extraArgs.ExcludePattern == nil) then
		excludePattern = ".svn";
	else
		excludePattern = extraArgs.ExcludePattern;	
	end
	local extraTargets;
	if (extraArgs == nil or extraArgs.ExtraTargets == nil) then
		extraTargets = "";
	else
		extraTargets = extraArgs.ExtraTargets;	
	end
	createJamroot(library, sources, outputPath, excludePattern, extraTargets);
	local rtnCode = os.execute("bjam " .. outputPath.AbsolutePath)
    print("BJAM return code = " .. rtnCode .. ".")
    if (rtnCode ~= 0) then
        error("Call to Boost.Build failed.")
        return false;
    end    
end

function createJamroot(library, sources, outputPath, excludePattern, extraTargets)
	local buildjam = outputPath:NewPath("/jamroot.jam");
	print("Creating Boost.Build file at " .. buildjam.AbsolutePath .. ".");
	
	local writer = buildjam:CreateFile();		
	
	local forAllSourcesWrite = function(text) 
		-- Because this gets generated to the output path, a relative path will 
		-- work.
		 -- writer:Write(text('./')); -- outputPath.AbsolutePath));
		-- ^- Actually, NO, you can't do this, thanks to yet another undocumented
		-- "feature" of Boost.Build.  If you use "path.glob-tree" with a 
		-- relative path being the source directory, will first off the code 
		-- above is wrong because it generates ".//" which means Boost just
		-- ignores it.  But when I changed it to "./" suddenly Boost started
		-- trying to include targets from the calling project (this occured
		-- when trying to use Lua as a dependency with a generated Jamroot)!
		-- So instead you have to use the vanilla "glob-tree" to avoid
		-- this unexplained behavior.  Of course, maybe this means *ANY* use
		-- of "path.glob-tree" is doomed to failure if its in a project that
		-- is being referenced by another project! Wonderful!!
		-- Spend hours figuring this out.
		for i = 1, #sources do
			local source = sources[i];
			writer:Write(text(source.AbsolutePath));		
		end	
	end;
	
	writer:Write([[
# Generated by Macaroni.

import boost ;
import path ;

# this screws up the Install jamroot when used from dependencies, so I 
# commented it out:
# boost.use-project 1.42 ;  

# ditto
# import site-config ;


project
	:	usage-requirements
]]);
	writer:Write([[ <include>./ ]]);
	forAllSourcesWrite(function(src) return [[ <include>"]] .. src .. [[" ]]; end);
	writer:Write([[
	;
	
alias libSources
	:	]]);
	writer:Write([[ [ glob-tree *.c : ]] .. excludePattern .. [[ ]
					[ glob-tree *.cpp : ]] .. excludePattern .. [[ ] 
				]]);				  
	forAllSourcesWrite(function(src) return [[
		[ path.glob-tree "]] .. src .. [[/" : *.c : ]] .. excludePattern .. [[ ]
		[ path.glob-tree "]] .. src .. [[/" : *.cpp : ]] .. excludePattern .. [[ ]
		]]; end);
	for k, v in pairs(library.Dependencies) do
		local jamDir = dependencyJamDir(v);
		if (jamDir ~= nil) then
			writer:Write([["]] .. jamDir.AbsolutePath .. [[//libSources" ]]);
		end
	end
	writer:Write(" : ");
	writer:Write([[ <include>./ ]]);
	forAllSourcesWrite(function(src) return [[
		<include>"]] .. src .. [["		
		]]; end);
	writer:Write([[
	;	
    ]]);
    writer:Write(extraTargets);
    writer:Close();    
    
end

function dependencyJamDir(d)
	local success, path = pcall(d.FindInstallPath, d);		
	if (success) then			
		local pathText = path.AbsolutePath;
		local jamroot = path:NewPathForceSlash('Cpp/jamroot.jam');
		if (jamroot.Exists) then
			return path:NewPathForceSlash('Cpp');
		end
	end
	return nil;
end

function Install(library, sourcePaths, outputPath, installPath, extraArgs)
	-- Create a Jam file which simply points to the source files.
	-- Copy all C++ source to the folder.
	local dstPath = installPath:NewPathForceSlash("Cpp");
	local patterns = {[[\.c(pp)?$]], [[\.h(pp)?$]]}
	local paths = sourcePaths 	
	for k,pattern in ipairs(patterns) do
		for i = 0, #sourcePaths do			
			local path;
			if (i == 0) then 
				path = outputPath; 				
			else
				path = sourcePaths[i];
			end
			copyCppSource(pattern, path, dstPath);				
		end 
	end	
	
	local excludePattern;
	if (extraArgs == nil or extraArgs.ExcludePattern == nil) then
		excludePattern = ".svn";
	else
		excludePattern = extraArgs.ExcludePattern;	
	end
	--local iJam = dstPath:NewPathForceSlash('jamroot.jam');
	--local writer = iJam:CreateFile();
	--writer:Write([[
	--# Generated by Macaroni
	--
	--]]);
	--writer:Close();
	createJamroot(library, {}, dstPath, excludePattern, '')
	return nil; --{ mario = "One good game." };
end

-- Copy all .C, .CPP, .H and .HPP files to dir.=
function copyCppSource(regEx, src, dst) 
	local srcs = src:GetPaths(regEx);	
	for i = 1, #srcs do
		local child = srcs[i];
		if (not child.IsDirectory) then
			print(tostring(child.AbsolutePath) .. " ... " .. tostring(dst.AbsolutePath));
			--src:CreateDirectory();
			child:CopyToDifferentRootPath(dst);		
		else
			-- May not be necessary
			-- iterateDir(regEx, child, dst);
		end
	end
end

function Prepare(library, sourcePaths, outputPath, installPath, extraArgs)
end