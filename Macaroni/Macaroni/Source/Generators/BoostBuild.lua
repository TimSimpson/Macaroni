require "Macaroni.IO.GeneratedFileWriter";
require "Macaroni.Model.Library";
require "Macaroni.IO.Path";
--require "Macaroni.IO.PathList";


function Build(library, sources, outputPath, installPath, extraArgs)
	local excludePattern;
	if (extraArgs == nil or extraArgs.ExcludePattern == nil) then
		excludePattern = ".svn";
	else
		excludePattern = extraArgs.ExcludePattern;	
	end
	local extraTargets;
	if (extraArgs == nil or extraArgs.ExtraTargets == nil) then
		extraTargets = "";
	else
		extraTargets = extraArgs.ExtraTargets;	
	end
	createJamroot(library, sources, outputPath, excludePattern, extraTargets);
	local rtnCode = os.execute("bjam " .. outputPath.AbsolutePath)
    print("BJAM return code = " .. rtnCode .. ".")
    if (rtnCode ~= 0) then
        error("Call to Boost.Build failed.")
        return false;
    end
    return true;
end

function createJamroot(library, sources, outputPath, excludePattern, extraTargets)
	local buildjam = outputPath:NewPath("/jamroot.jam");
	print("Creating Boost.Build file at " .. buildjam.AbsolutePath .. ".");
	
	local writer = buildjam:CreateFile();		
	
	local forAllSourcesWrite = function(text) 
		-- Because this gets generated to the output path, a relative path will 
		-- work.
		writer:Write(text('./')); -- outputPath.AbsolutePath));
		for i = 1, #sources do
			local source = sources[i];
			writer:Write(text(source.AbsolutePath));		
		end	
	end;
	
	writer:Write([[
# Generated by Macaroni.

import boost ;
import path ;

# this screws up the Install jamroot when used from dependencies, so I 
# commented it out:
# boost.use-project 1.42 ;  

# ditto
# import site-config ;


project
	:	usage-requirements
]]);
	forAllSourcesWrite(function(src) return " <include>" .. src .. " "; end);
	writer:Write([[
	;
	
alias libSources
	:	]]);
	forAllSourcesWrite(function(src) return [[
		[ path.glob-tree ]] .. src .. [[/ : *.c : ]] .. excludePattern .. [[ ]
		[ path.glob-tree ]] .. src .. [[/ : *.cpp : ]] .. excludePattern .. [[ ]
		]]; end);
	for k, v in pairs(library.Dependencies) do
		local jamDir = dependencyJamDir(v);
		if (jamDir ~= nil) then
			writer:Write(jamDir.AbsolutePath .. '//libSources ');
		end
	end
	writer:Write(" : ");
	forAllSourcesWrite(function(src) return [[
		<include>]] .. src .. [[		
		]]; end);
	writer:Write([[
	;	
    ]]);
    writer:Write(extraTargets);
    writer:Close();    
    
end

function dependencyJamDir(d)
	local success, path = pcall(d.FindInstallPath, d);		
	if (success) then			
		local pathText = path.AbsolutePath;
		local jamroot = path:NewPathForceSlash('Cpp/jamroot.jam');
		if (jamroot.Exists) then
			return path:NewPathForceSlash('Cpp');
		end
	end
	return nil;
end

function Install(library, sourcePaths, outputPath, installPath, extraArgs)
	-- Create a Jam file which simply points to the source files.
	-- Copy all C++ source to the folder.
	local dstPath = installPath:NewPathForceSlash("Cpp");
	local patterns = {[[\.c(pp)?$]], [[\.h(pp)?$]]}
	local paths = sourcePaths 	
	for k,pattern in ipairs(patterns) do
		for i = 0, #sourcePaths do			
			local path;
			if (i == 0) then 
				path = outputPath; 				
			else
				path = sourcePaths[i];
			end
			copyCppSource(pattern, path, dstPath);				
		end 
	end	
	
	local excludePattern;
	if (extraArgs == nil or extraArgs.ExcludePattern == nil) then
		excludePattern = ".svn";
	else
		excludePattern = extraArgs.ExcludePattern;	
	end
	--local iJam = dstPath:NewPathForceSlash('jamroot.jam');
	--local writer = iJam:CreateFile();
	--writer:Write([[
	--# Generated by Macaroni
	--
	--]]);
	--writer:Close();
	createJamroot(library, {}, dstPath, excludePattern, '')
end

-- Copy all .C, .CPP, .H and .HPP files to dir.=
function copyCppSource(regEx, src, dst) 
	local srcs = src:GetPaths(regEx);	
	for i = 1, #srcs do
		local child = srcs[i];
		if (not child.IsDirectory) then
			print(tostring(child.AbsolutePath) .. " ... " .. tostring(dst.AbsolutePath));
			--src:CreateDirectory();
			child:CopyToDifferentRootPath(dst);		
		else
			-- May not be necessary
			-- iterateDir(regEx, child, dst);
		end
	end
end

function Prepare(library, sourcePaths, outputPath, installPath, extraArgs)
end