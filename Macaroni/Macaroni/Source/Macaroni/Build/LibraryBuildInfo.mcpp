////~import Macaroni::Model::Context;
////~import Macaroni::Model::ContextPtr;
////~import Macaroni::Build::Library;
////~import Macaroni::Build::LibraryPtr;
////~import Macaroni::Build::Manifest;
////~import Macaroni::Build::ManifestPtr;
////~import boost::optional;
////~import boost::filesystem::path;
////
////namespace Macaroni::Build 
////{
////
/////** Information about building a library, with the actual library (not just the
//// * ID), the Manifest, its parents and its dependencies. */
////class LibraryBuildInfo
////{	
////	private vector<LibraryBuildInfoPtr> children;
////	private ContextPtr context;
////	private LibraryPtr library;
////	private ManifestPtr manifest;
////	private optional<LibraryBuildInfoPtr> parent;
////
////	public LibraryBuildInfo(ContextPtr context, path manifestFilePath)
////		: children(), context(context), library(), manifest(), parent()
////	{
////		struct Resolve : public LocalManifestResolver 
////		{
////			virtual optional<LibraryId> FindParent(const optional<string &> & parentPath) 
////			{
////				bool mustExist = false;
////				path filePath;
////				if (!parentPath)
////				{
////					filePath = manifestPath.branch_path();					
////				}
////				else
////				{
////					filePath = manifestPath / (parentPath.get());
////					mustExist = true;
////				}				
////				if (!boost::filesystem::exists(filePath))
////				{
////					if (mustExist) 
////					{
////						stringstream ss;
////						ss	<< "Could not find parent manifest of \""
////							<< manifestPath << "\" given the path \""
////							<< parentPath << "\".";
////						throw Exception(ss.str().c_str());
////					}
////					return optional<LibraryId>();
////				}
////
////			}
////	
////			virtual LibraryId FindChild(const std::string & childPath) = 0;
////
////			virtual void SelfLibraryId(const LibraryId & myId)
////			{
////
////			}
////		};		
////
////		manifest(new Manifest(manifestFilePath, properties));
////		manifest = newM;
////		manifest->
////		LibraryPtr newL(context->FindOrCreateLibrary(manifest->GetId()));
////		library = newL;
////	}
////};
////
////typedef shared_ptr<LibraryBuildInfo> LibraryBuildInfoPtr;
////
////} // end namespace