~import Macaroni::Build::Cpp::CompilerSettings;
~import Macaroni::Build::Configuration;
~import Macaroni::Build::ConfigurationId;
~import Macaroni::Exception;
~import Macaroni::Build::Manifest;
~import nullptr;
~import std::string;
~import std::stringstream;
~import std::vector;

namespace Macaroni::Build::Cpp {

class LinkerSettings
{
	private vector<const string> libPaths;

	/*public LinkerSettings(CompilerSettings & compiler, Configuration & config)
	:	libPaths(),
	{
		addCompilerLibPaths(compiler);
		addConfigurationLibPaths(config);
	}*/		

	public void AddCompilerLibPaths(const CompilerSettings & compiler)
	{
		libPaths.clear();
		for (unsigned int i = 0; i < compiler.GetLinkerLibraryPaths().size(); i ++)
		{
			libPaths.push_back(compiler.GetLinkerLibraryPaths()[i]);
		} 		
	}

	public void AddConfigurationLibPaths(const Configuration & config)	
	{
		const vector<const string> configLibs = config.GetLinkerLibraries();
		for (unsigned int j = 0; j < configLibs.size(); j ++)
		{
			libPaths.push_back(configLibs[j]);
		}

		const vector<const ConfigurationId> & dependencies = config.GetDependencies();
		for (unsigned int i = 0; i < dependencies.size(); i ++)
		{
			const ConfigurationId & cId = dependencies[i];
			Manifest dm(cId.GetManifestId().FindFinalManifestFile());	
			const Configuration * dConfig = dm.GetConfiguration(cId.GetName());
			if (dConfig == nullptr)
			{
				stringstream ss;
				ss << "Could not find configuration \"" 
					<< cId.GetName() << " for dependency (" 
					<< cId.GetManifestId().GetGroup() << ", "
					<< cId.GetManifestId().GetName() << ", "
					<< cId.GetManifestId().GetVersion() 
					<< ").";
				throw Macaroni::Exception(ss.str().c_str());
			}
			AddConfigurationLibPaths(*dConfig);
		}		
	}
	
	public const vector<const string> & GetLibPaths() const
	{
		return libPaths;
	}
	
};

} // end namespace