~import BOOST_FOREACH;
~import Macaroni::Environment::Console;
~import Macaroni::Model::Context;
~import Macaroni::Model::ContextPtr;
~import Macaroni::Build::Cpp::CppFile;
~import boost::filesystem::create_directories;
~import Macaroni::Exception;
~import Macaroni::IO::FileSet;
~import Macaroni::Build::GeneratorContext;
~import Macaroni::Build::InstallContext;
~import Macaroni::Build::InstallContextPtr;
~import Macaroni::Model::Library;
~import Macaroni::Model::LibraryPtr;
~import Macaroni::Build::Manifest;
~import Macaroni::Build::ManifestPtr;
~import Macaroni::Build::MCompiler;
~import Macaroni::Build::MCompilerOptions;
~import Macaroni::Parser::ParserException;
~import boost::filesystem::path;
~import Macaroni::IO::Path;
~import Macaroni::IO::PathPtr;
~import Macaroni::IO::Paths;
~import Macaroni::Environment::Process;
~import boost::shared_ptr;
~import Macaroni::Model::Source;
~import std::string;
~import std::stringstream;
~import std::vector;

namespace Macaroni::Build {

/* Governs the main execution routine of Macaroni.
	 * Options:
	 * 	generate - Call "generate" function of manifest.  This
	 *  is where the generation of extra information in the AST or C++ source 
	 *  code occurs.
	 *  build - After "generate" phase, call build routines.  These are utility
	 *  functions for building the project through Macaroni.
	 *  install - Copy resources  
*/
class Builder
{	
	private const Console & console;
	private vector<CppFile> cppFiles;
	private vector<const string> cppSrcRoots;
	private bool install;
	private LibraryPtr library;
	private ManifestPtr manifest;

	public Builder(ContextPtr context, ManifestPtr manifest,
		Console & console, bool install)
	:	console(console),
		install(install),
		library(context->CreateLibrary(manifest->GetName(), manifest->GetVersion())),
		manifest(manifest)
	{
	}

	
	public bool CopyCppFiles(path exportCppDir)
	{
		std::vector<Path> cppFiles;

        BOOST_FOREACH(const string & srcDirectory, cppSrcRoots)
		{
			boost::filesystem::path srcDirectoryPath =
				boost::filesystem::path(srcDirectory);
			FileSet input(srcDirectoryPath, "\\.c(pp)?$");
			FileSet::Iterator itr2 = input.Begin();
			FileSet::Iterator end = input.End();
			for(; itr2 != end; ++ itr2)
			{
				Path path(srcDirectoryPath, *itr2);
				path.CopyToDifferentRootPath(exportCppDir);
			}
		}

		return true;
	}

	public bool CopyHeaderFiles(path headersDir)
	{
		std::vector<Path> hFiles;

        BOOST_FOREACH(const string & srcDirectory, cppSrcRoots)
		{
            boost::filesystem::path srcDirectoryPath =
				boost::filesystem::path(srcDirectory);
			FileSet input(srcDirectoryPath, "\\.h(pp)?$");
			FileSet::Iterator itr2 = input.Begin();
			FileSet::Iterator end = input.End();
			for(; itr2 != end; ++ itr2)
			{
				Path path(srcDirectoryPath, *itr2);
				path.CopyToDifferentRootPath(headersDir);
			}
		}

		return true;
	}

	private void createCppFileList()
	{
		cppFiles = std::vector<CppFile>();

		//console.WriteLine("~ Generating listing of C++ source files. ~");
		const Path rootDir(manifest->GetRootDirectory(), manifest->GetRootDirectory());
		//PathPtr mWork = rootDir.NewPath("./MWork");
		PathPtr objFilesDirRoot = rootDir.NewPathForceSlash(manifest->GetCppOutput());
		// TODO: Configs- and CppFiles- are no longer needed, remove:
		PathPtr objFilesDir = objFilesDirRoot->NewPathForceSlash("oldConfigName");
		//objFilesDir->CreateDirectory();

        BOOST_FOREACH(const string & srcDirectory, cppSrcRoots)
        {
			boost::filesystem::path srcDirectoryPath =
				boost::filesystem::path(srcDirectory);
			FileSet input(srcDirectoryPath, "\\.c(pp)?$");
			FileSet::Iterator itr2 = input.Begin();
			FileSet::Iterator end = input.End();
			for(; itr2 != end; ++ itr2)
			{
				boost::filesystem::path p = *itr2;
				cppFiles.push_back(CppFile(srcDirectoryPath,
								p,
								objFilesDir->GetAbsolutePath()));
			}
		}
	}

	private void createCppSrcRoots()
	{
		cppSrcRoots = manifest->GetMSource();
		cppSrcRoots.push_back(manifest->GetMOutput());
		for (unsigned int i = 0; i < cppSrcRoots.size(); i ++)
        {
            boost::filesystem::path srcPath(cppSrcRoots[i]);
            cppSrcRoots[i] = boost::filesystem::system_complete(srcPath).string();
        }
	}

	//TODO: In Macaroni 0.1.0.4, this does not work.  Causes error:
	//addDependencyNode was passed Macaroni::Environment::Console, which is a hollow node..
	~block "h"
	{
		private :  BuildContextPtr createBuildContext();
	}
	~block "cpp"
	{
		BuildContextPtr Builder::createBuildContext()
		{
			const Path dir(manifest->GetRootDirectory(), 
						   manifest->GetRootDirectory());
			vector<PathPtr> sources;
			BOOST_FOREACH(const std::string & srcDirectory, manifest->GetMSource())
			{				
				sources.push_back(dir.NewPathForceSlash(srcDirectory));
			}
			PathPtr genSrc = dir.NewPathForceSlash(manifest->GetMOutput());
			path installPath = getInstallPath();
			PathPtr installPathPtr(new Path(installPath, installPath));
			BuildContextPtr iCon(new BuildContext(library, sources, genSrc, installPathPtr));
			return iCon;
		}
	}

	public bool CreateInterface()
	{
		return CreateInterfaceMh();
	}

	public bool CreateInterfaceMh()
	{
		return true;
	}

	//TO-DO : Change "compile" to "build".
	public bool Execute(bool generate, bool saveCppSource, bool compile, bool install)
	{
		generate = generate || compile || install;
		compile = compile || install;
		
		console.WriteLine("--------------------------------------------------------------------------------");
		console.Write("    ");
		console.WriteLine(manifest->GetName());		
		console.WriteLine("--------------------------------------------------------------------------------");

		const Path dir(manifest->GetRootDirectory(), manifest->GetRootDirectory());
		//PathPtr mWork = dir.NewPathForceSlash("./MWork");
		//mWork->CreateDirectory();

		PathPtr genSrc = dir.NewPathForceSlash(manifest->GetMOutput());//"/GeneratedSource");
		genSrc->CreateDirectory();

		bool success = true;
		if (generate)
		{
			success = ParseMacaroniSource();
			if (success)
			{
				BuildContextPtr iCon = createBuildContext();
				//GeneratorContextPtr gCon(new GeneratorContext(library, genSrc));
				success = manifest->RunTarget(console, iCon, "generate", "Generate");
			}
		}

		if (success)
		{
			if (compile)
			{				
				//const Path dir(manifest->GetRootDirectory(), manifest->GetRootDirectory());
				//PathPtr genSrc = dir.NewPathForceSlash(manifest->GetMOutput());//"/GeneratedSource");		
				//PathPtr src(new Path(manifest->GetRootDirectory(), manifest->GetRootDirectory()));
				//path installPath = getInstallPath();
				//PathPtr installPathPtr(new Path(installPath, installPath));
				BuildContextPtr iCon = createBuildContext();//new BuildContext(library, src, genSrc, installPathPtr));
				success = manifest->RunTarget(console, iCon, "build", "Build");
			}

			createCppSrcRoots();
			createCppFileList();

			if (saveCppSource)
			{
				success = SaveCppSource();
			}
			if (install)
			{				
			    success = Install();
			}
		}

		if (success)
		{
			console.WriteLine(" ~ YOU WIN! ~ ");
		}
		else
		{
			console.WriteLine(" ~ GAME OVER ~ ");
		}
		return success;
	}

	private path getInstallPath()
	{
		path userPath(Paths::GetUserPath());
		return userPath / "Libraries" / manifest->GetGroup()
						/ manifest->GetName() / manifest->GetVersion();		
	}

	public bool Install()
	{
		path installPath = getInstallPath();
		if (boost::filesystem::exists(installPath))
		{
			boost::filesystem::remove_all(installPath);
		}
		else
		{
			boost::filesystem::create_directories(installPath);
		}

		// Interface.mh - copy this file to root of directory.
		path localMhInterface(manifest->GetRootDirectory());
		localMhInterface = localMhInterface / manifest->GetMOutput();
		localMhInterface = localMhInterface / "Interface.mh";
		//path exportMhInterfaceDir(installPath);
		//exportMhInterfaceDir = exportMhInterfaceDir;
		//boost::filesystem::create_directories(exportMhInterfaceDir);
		//path exportMhInterface = exportMhInterfaceDir/ "Interface.mh";
		//boost::filesystem::copy_file(localMhInterface, exportMhInterface);

		//const Path dir(manifest->GetRootDirectory(), manifest->GetRootDirectory());
		//PathPtr genSrc = dir.NewPathForceSlash(manifest->GetMOutput());//"/GeneratedSource");		
		//PathPtr src(new Path(manifest->GetRootDirectory(), manifest->GetRootDirectory()));
		//PathPtr installPathPtr(new Path(installPath, installPath));
		BuildContextPtr iCon = createBuildContext(); //(new BuildContext(library, src, genSrc, installPathPtr));
		return manifest->RunTarget(console, iCon, "install", "Install");
		//Path::CopyDirectoryContents(headersLocal, headersInstall);
		// return true;
	}
	
	public bool ParseMacaroniSource()
	{
		console.WriteLine("~ Creating Macaroni model from source files (.mh, .mcpp). ~");

		std::string mSrc = manifest->GetMSource()[0];
		std::string mOut = manifest->GetMOutput();
		std::vector<FileSet> inputFiles;

		MCompiler compiler;

		// Include dependencies
		BOOST_FOREACH(ManifestPtr dependency, manifest->GetDependencies()) 
		{
			const LibraryId id = dependency->GetId();
			Manifest dManifest(id.FindFinalManifestFile());
			const std::vector<const std::string> dSrc = dManifest.GetMSource();
			BOOST_FOREACH(const string & dir, dSrc)
			{
				LibraryPtr dLib = library->GetContext()->CreateLibrary(
					dManifest.GetName(), dManifest.GetVersion());
				std::vector<FileSet> dInput;
				dInput.push_back(FileSet(boost::filesystem::path(dir), "\\.m(cpp|h)?$"));
				compiler.BuildModel(dLib, dInput);
				//compiler.BuildModel(library, dInput);
			}
		}
		// end include dependencies

		inputFiles.push_back(FileSet(boost::filesystem::path(mSrc), "\\.mcpp$"));

		std::vector<const std::string> blankGeneratorSelection;
		MCompilerOptions options(inputFiles,
								 boost::filesystem::path(mOut),
								 blankGeneratorSelection);

		try
		{
			compiler.Compile(library, options);
		}
		catch(Macaroni::Exception & ex)
		{
			console.WriteLine("An error occured during Macaroni phase.");
			console.WriteLine(ex.GetSource());
			console.WriteLine(ex.GetMessage());
			return false;
		}
		catch(Macaroni::Parser::ParserException & pe)
		{
			console.WriteLine("Error parsing Macaroni code: ");
			console.WriteLine(pe.GetSource()->ToString());
			console.WriteLine(pe.GetMessage());
			return false;
		}
		return true;
	}


	public bool SaveCppSource()
	{
		createCppSrcRoots();
        createCppFileList();

		path cppSourceLocal(manifest->GetCppSourceOutput());

		std::stringstream ss;
		ss << "Saving generated and non-generated C++ source code to " <<
				cppSourceLocal.string() << ".";
		console.WriteLine(ss.str());

		boost::filesystem::create_directories(cppSourceLocal);
		CopyHeaderFiles(cppSourceLocal);
		CopyCppFiles(cppSourceLocal);
		return true;
	}

};

} // end namespace

