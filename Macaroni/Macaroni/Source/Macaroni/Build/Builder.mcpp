~import BOOST_FOREACH;
~import Macaroni::Environment::Console;
~import Macaroni::Build::Configuration;
~import Macaroni::Model::Context;
~import Macaroni::Model::ContextPtr;
~import Macaroni::Build::Cpp::CppFile;
~import boost::filesystem::create_directories;
~import Macaroni::Exception;
~import Macaroni::IO::FileSet;
~import Macaroni::Model::Library;
~import Macaroni::Model::LibraryPtr;
~import Macaroni::Build::Manifest;
~import Macaroni::Build::MCompiler;
~import Macaroni::Build::MCompilerOptions;
~import Macaroni::Parser::ParserException;
~import boost::filesystem::path;
~import Macaroni::IO::Path;
~import Macaroni::IO::PathPtr;
~import Macaroni::IO::Paths;
~import Macaroni::Environment::Process;
~import boost::shared_ptr;
~import Macaroni::Model::Source;
~import std::string;
~import std::stringstream;
~import std::vector;

namespace Macaroni::Build {

class Builder
{
	private const Configuration & configuration;
	private const Console & console;
	private vector<CppFile> cppFiles;
	private vector<const string> cppSrcRoots;
	private bool install;
	private LibraryPtr library;
	private const Manifest & manifest;

	public Builder(ContextPtr context, const Manifest & manifest,
		const Configuration & config, Console & console, bool install)
	:	configuration(config),
		console(console),
		install(install),
		library(context->CreateLibrary(manifest.GetName(), manifest.GetVersion())),
		manifest(manifest)
	{
	}

	public bool CompileMacaroni()
	{
		console.WriteLine("~ Compiling Macaroni Source into C++ ~");

		std::string mSrc = manifest.GetMSource()[0];
		std::string mOut = manifest.GetMOutput();
		std::vector<FileSet> inputFiles;

		MCompiler compiler;

		// Include dependencies
		const std::vector<const ConfigurationId> & dependencies = this->configuration.GetDependencies();
		BOOST_FOREACH(const ConfigurationId & dependency, dependencies)
		{
			const ManifestId & id = dependency.GetManifestId();
			Manifest dManifest(id.FindFinalManifestFile());
			const std::vector<const std::string> dSrc = dManifest.GetMSource();
			BOOST_FOREACH(const string & dir, dSrc)
			{
				LibraryPtr dLib = library->GetContext()->CreateLibrary(
					dManifest.GetName(), dManifest.GetVersion());
				std::vector<FileSet> dInput;
				dInput.push_back(FileSet(boost::filesystem::path(dir), "\\.m(cpp|h)?$"));
				compiler.BuildModel(dLib, dInput);
				//compiler.BuildModel(library, dInput);
			}
		}
		// end include dependencies

		inputFiles.push_back(FileSet(boost::filesystem::path(mSrc), "\\.mcpp$"));

		MCompilerOptions options(inputFiles,
								 boost::filesystem::path(mOut),
								 configuration.GetGenerators());

		try
		{
			compiler.Compile(library, options);
		}
		catch(Macaroni::Exception & ex)
		{
			console.WriteLine("An error occured during Macaroni phase.");
			console.WriteLine(ex.GetSource());
			console.WriteLine(ex.GetMessage());
			return false;
		}
		catch(Macaroni::Parser::ParserException & pe)
		{
			console.WriteLine("Error parsing Macaroni code: ");
			console.WriteLine(pe.GetSource()->ToString());
			console.WriteLine(pe.GetMessage());
			return false;
		}
		return true;
	}

	public bool CopyCppFiles(path exportCppDir)
	{
		std::vector<Path> cppFiles;

        BOOST_FOREACH(const string & srcDirectory, cppSrcRoots)
		{
			boost::filesystem::path srcDirectoryPath =
				boost::filesystem::path(srcDirectory);
			FileSet input(srcDirectoryPath, "\\.c(pp)?$");
			FileSet::Iterator itr2 = input.Begin();
			FileSet::Iterator end = input.End();
			for(; itr2 != end; ++ itr2)
			{
				Path path(srcDirectoryPath, *itr2);
				path.CopyToDifferentRootPath(exportCppDir);
			}
		}

		return true;
	}

	public bool CopyHeaderFiles(path headersDir)
	{
		std::vector<Path> hFiles;

        BOOST_FOREACH(const string & srcDirectory, cppSrcRoots)
		{
            boost::filesystem::path srcDirectoryPath =
				boost::filesystem::path(srcDirectory);
			FileSet input(srcDirectoryPath, "\\.h(pp)?$");
			FileSet::Iterator itr2 = input.Begin();
			FileSet::Iterator end = input.End();
			for(; itr2 != end; ++ itr2)
			{
				Path path(srcDirectoryPath, *itr2);
				path.CopyToDifferentRootPath(headersDir);
			}
		}

		return true;
	}

	private void createCppFileList()
	{
		cppFiles = std::vector<CppFile>();

		console.WriteLine("~ Generating listing of C++ source files. ~");
		const Path rootDir(manifest.GetRootDirectory(), manifest.GetRootDirectory());
		//PathPtr mWork = rootDir.NewPath("./MWork");
		PathPtr objFilesDirRoot = rootDir.NewPathForceSlash(manifest.GetCppOutput());
		PathPtr objFilesDir = objFilesDirRoot->NewPathForceSlash(configuration.GetName());
		objFilesDir->CreateDirectory();

        BOOST_FOREACH(const string & srcDirectory, cppSrcRoots)
        {
			boost::filesystem::path srcDirectoryPath =
				boost::filesystem::path(srcDirectory);
			FileSet input(srcDirectoryPath, "\\.c(pp)?$");
			FileSet::Iterator itr2 = input.Begin();
			FileSet::Iterator end = input.End();
			for(; itr2 != end; ++ itr2)
			{
				boost::filesystem::path p = *itr2;
				cppFiles.push_back(CppFile(srcDirectoryPath,
								p,
								objFilesDir->GetAbsolutePath()));
			}
		}
	}

	private void createCppSrcRoots()
	{
		cppSrcRoots = manifest.GetMSource();
		cppSrcRoots.push_back(manifest.GetMOutput());
		for (unsigned int i = 0; i < cppSrcRoots.size(); i ++)
        {
            boost::filesystem::path srcPath(cppSrcRoots[i]);
            cppSrcRoots[i] = boost::filesystem::system_complete(srcPath).string();
        }
	}

	public bool CreateInterface()
	{
		return CreateInterfaceMh();
	}

	public bool CreateInterfaceMh()
	{
		return true;
	}

	public void Execute(bool generate, bool saveCppSource, bool compile, bool install)
	{
		console.WriteLine("--------------------------------------------------------------------------------");
		console.Write("Configuration: "); console.WriteLine(configuration.GetName());
		console.WriteLine("--------------------------------------------------------------------------------");

		const Path dir(manifest.GetRootDirectory(), manifest.GetRootDirectory());
		PathPtr mWork = dir.NewPathForceSlash("./MWork");
		mWork->CreateDirectory();

		PathPtr genSrc = mWork->NewPathForceSlash("/GeneratedSource");
		genSrc->CreateDirectory();

		bool success = true;
		if (generate)
		{
			success = CompileMacaroni();
		}

		if (success)
		{
			createCppSrcRoots();
			createCppFileList();

			if (saveCppSource)
			{
				success = SaveCppSource();
			}
			if (install)
			{
			    Install();
			}
		}

		if (success)
		{
			console.WriteLine(" ~ YOU WIN! ~ ");
		}
		else
		{
			console.WriteLine(" ~ GAME OVER ~ ");
		}
	}

	public bool Install()
	{
		path userPath(Paths::GetUserPath());
		path installPath = userPath / "Libraries" / manifest.GetGroup()
							/ manifest.GetName() / manifest.GetVersion();
		if (boost::filesystem::exists(installPath))
		{
			boost::filesystem::remove_all(installPath);
		}
		else
		{
			boost::filesystem::create_directories(installPath);
		}

		// Interface.mh - copy this file to root of directory.
		path localMhInterface(manifest.GetRootDirectory());
		localMhInterface = localMhInterface / manifest.GetMOutput();
		localMhInterface = localMhInterface / "Interface.mh";
		path exportMhInterfaceDir(installPath);
		exportMhInterfaceDir = exportMhInterfaceDir;
		boost::filesystem::create_directories(exportMhInterfaceDir);
		path exportMhInterface = exportMhInterfaceDir/ "Interface.mh";
		boost::filesystem::copy_file(localMhInterface, exportMhInterface);

		//Path::CopyDirectoryContents(headersLocal, headersInstall);
		return true;
	}

	public bool SaveCppSource()
	{
		createCppSrcRoots();
        createCppFileList();

		path cppSourceLocal(manifest.GetCppSourceOutput());

		std::stringstream ss;
		ss << "Saving generated and non-generated C++ source code to " <<
				cppSourceLocal.string() << ".";
		console.WriteLine(ss.str());

		boost::filesystem::create_directories(cppSourceLocal);
		CopyHeaderFiles(cppSourceLocal);
		CopyCppFiles(cppSourceLocal);
		return true;
	}

};

} // end namespace

