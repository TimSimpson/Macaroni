~import BOOST_FOREACH;
~import Macaroni::Environment::Console;
~import Macaroni::Model::Context;
~import Macaroni::Model::ContextPtr;
~import Macaroni::Build::Cpp::CppFile;
~import boost::filesystem::create_directories;
~import Macaroni::Exception;
~import Macaroni::IO::FileSet;
~import Macaroni::Build::GeneratorContext;
~import Macaroni::Build::InstallContext;
~import Macaroni::Build::InstallContextPtr;
~import Macaroni::Model::Library;
~import Macaroni::Build::LibraryId;
~import Macaroni::Model::LibraryPtr;
~import Macaroni::Environment::LuaEnvironment;
~import Macaroni::Build::Manifest;
~import Macaroni::Build::ManifestPtr;
~import Macaroni::Build::MCompiler;
~import Macaroni::Build::MCompilerOptions;
~import Macaroni::Parser::ParserException;
~import boost::filesystem::path;
~import Macaroni::IO::Path;
~import Macaroni::IO::PathPtr;
~import Macaroni::IO::Paths;
~import Macaroni::Environment::Process;
~import boost::shared_ptr;
~import Macaroni::Model::Source;
~import std::string;
~import std::stringstream;
~import std::vector;

namespace Macaroni::Build {

/* Governs the main execution routine of Macaroni.
	 * Options:
	 * 	generate - Call "generate" function of manifest.  This
	 *  is where the generation of extra information in the AST or C++ source 
	 *  code occurs.
	 *  build - After "generate" phase, call build routines.  These are utility
	 *  functions for building the project through Macaroni.
	 *  install - Copy resources  
*/
class Builder
{	
	private const Console & console;
	private ContextPtr context;
	private vector<CppFile> cppFiles;
	private vector<const string> cppSrcRoots;
	private bool install;
	private LibraryPtr library;
	private ManifestPtr manifest;
	private path manifestPath;
	private MCompiler compiler;
	private string properties;

	public Builder(ContextPtr context, path manifestPath,
		Console & console, bool install)
	:	compiler(),
		console(console),
		context(context),
		install(install),
		library(),//GetName(), manifest->GetVersion())),
		manifest(),
		manifestPath(manifestPath),
		properties()
	{
	}

	
	public bool CopyCppFiles(path exportCppDir)
	{
		std::vector<Path> cppFiles;

        BOOST_FOREACH(const string & srcDirectory, cppSrcRoots)
		{
			boost::filesystem::path srcDirectoryPath =
				boost::filesystem::path(srcDirectory);
			FileSet input(srcDirectoryPath, "\\.c(pp)?$");
			FileSet::Iterator itr2 = input.Begin();
			FileSet::Iterator end = input.End();
			for(; itr2 != end; ++ itr2)
			{
				Path path(srcDirectoryPath, *itr2);
				path.CopyToDifferentRootPath(exportCppDir);
			}
		}

		return true;
	}

	public bool CopyHeaderFiles(path headersDir)
	{
		std::vector<Path> hFiles;

        BOOST_FOREACH(const string & srcDirectory, cppSrcRoots)
		{
            boost::filesystem::path srcDirectoryPath =
				boost::filesystem::path(srcDirectory);
			FileSet input(srcDirectoryPath, "\\.h(pp)?$");
			FileSet::Iterator itr2 = input.Begin();
			FileSet::Iterator end = input.End();
			for(; itr2 != end; ++ itr2)
			{
				Path path(srcDirectoryPath, *itr2);
				path.CopyToDifferentRootPath(headersDir);
			}
		}

		return true;
	}

	private void createCppFileList()
	{
		cppFiles = std::vector<CppFile>();

		//console.WriteLine("~ Generating listing of C++ source files. ~");
		const Path rootDir(manifest->GetRootDirectory(), manifest->GetRootDirectory());
		//PathPtr mWork = rootDir.NewPath("./MWork");
		PathPtr objFilesDirRoot = rootDir.NewPathForceSlash(manifest->GetCppOutput());
		// TODO: Configs- and CppFiles- are no longer needed, remove:
		PathPtr objFilesDir = objFilesDirRoot->NewPathForceSlash("oldConfigName");
		//objFilesDir->CreateDirectory();

        BOOST_FOREACH(const string & srcDirectory, cppSrcRoots)
        {
			boost::filesystem::path srcDirectoryPath =
				boost::filesystem::path(srcDirectory);
			FileSet input(srcDirectoryPath, "\\.c(pp)?$");
			FileSet::Iterator itr2 = input.Begin();
			FileSet::Iterator end = input.End();
			for(; itr2 != end; ++ itr2)
			{
				boost::filesystem::path p = *itr2;
				cppFiles.push_back(CppFile(srcDirectoryPath,
								p,
								objFilesDir->GetAbsolutePath()));
			}
		}
	}

	private void createCppSrcRoots()
	{
		cppSrcRoots = manifest->GetMSource();
		cppSrcRoots.push_back(manifest->GetMOutput());
		for (unsigned int i = 0; i < cppSrcRoots.size(); i ++)
        {
            boost::filesystem::path srcPath(cppSrcRoots[i]);
            cppSrcRoots[i] = boost::filesystem::system_complete(srcPath).string();
        }
	}

	//TODO: In Macaroni 0.1.0.4, this does not work.  Causes error:
	//addDependencyNode was passed Macaroni::Environment::Console, which is a hollow node..
	~block "h"
	{
		private :  BuildContextPtr createBuildContext(ManifestPtr manifest);
	}
	~block "cpp"
	{
		BuildContextPtr Builder::createBuildContext(ManifestPtr manifest)
		{
			//const Path dir(manifest->GetRootDirectory(), 
			//			   manifest->GetRootDirectory());
			vector<PathPtr> sources;
			BOOST_FOREACH(const std::string & srcDirectory, manifest->GetMSource())
			{							
				path sd(srcDirectory);
				PathPtr newPath(new Path(sd)); //manifest->GetRootDirectory() / srcDirectory));
				sources.push_back(newPath);
			}
			path od(manifest->GetMOutput());
			PathPtr genSrc(new Path(od)); //manifest->GetRootDirectory() / manifest->GetMOutput()));
			path installPath = getInstallPath();
			PathPtr installPathPtr(new Path(installPath, installPath));
			BuildContextPtr iCon(new BuildContext(library, sources, genSrc, installPathPtr, properties));
			return iCon;
		}
	}

	public bool CreateInterface()
	{
		return CreateInterfaceMh();
	}

	public bool CreateInterfaceMh()
	{
		return true;
	}

	//TO-DO : Change "compile" to "build".
	public bool Execute(bool generate, bool saveCppSource, bool compile, bool install)
	{
		generate = generate || compile || install;
		compile = compile || install;
		
		Init();

		console.WriteLine("--------------------------------------------------------------------------------");
		console.Write("    ");
		console.WriteLine(manifest->GetName());		
		console.WriteLine("--------------------------------------------------------------------------------");

		

		const Path dir(manifest->GetRootDirectory(), manifest->GetRootDirectory());
		//PathPtr mWork = dir.NewPathForceSlash("./MWork");
		//mWork->CreateDirectory();

		PathPtr genSrc = dir.NewPathForceSlash(manifest->GetMOutput());//"/GeneratedSource");
		genSrc->CreateDirectory();

		bool success = true;
		if (generate)
		{
			success = ParseMacaroniSource();
			if (success)
			{
				BuildContextPtr iCon = createBuildContext(manifest);
				//GeneratorContextPtr gCon(new GeneratorContext(library, genSrc));
				success = manifest->RunTarget(console, iCon, "generate", "Generate")->Success;
			}
		}

		if (success)
		{
			if (compile)
			{				
				//const Path dir(manifest->GetRootDirectory(), manifest->GetRootDirectory());
				//PathPtr genSrc = dir.NewPathForceSlash(manifest->GetMOutput());//"/GeneratedSource");		
				//PathPtr src(new Path(manifest->GetRootDirectory(), manifest->GetRootDirectory()));
				//path installPath = getInstallPath();
				//PathPtr installPathPtr(new Path(installPath, installPath));
				BuildContextPtr iCon = createBuildContext(manifest);//new BuildContext(library, src, genSrc, installPathPtr));
				success = manifest->RunTarget(console, iCon, "build", "Build")->Success;
			}

			createCppSrcRoots();
			createCppFileList();

			if (saveCppSource)
			{
				success = SaveCppSource();
			}
			if (install)
			{				
			    success = Install();
			}
		}

		if (success)
		{
			console.WriteLine(" ~ YOU WIN! ~ ");
		}
		else
		{
			console.WriteLine(" ~ GAME OVER ~ ");
		}
		return success;
	}

	private path getInstallPath()
	{
		path userPath(Paths::GetUserPath());
		return userPath / "Libraries" / manifest->GetGroup()
						/ manifest->GetName() / manifest->GetVersion();		
	}

	/** Runs init.lua in Macaroni user directory to establish base
	 * settings, then initializes manifest and prepares all
	 * found dependencies.
	 */
	public void Init()
	{		
		properties = RunInitialScript();
		ManifestPtr newM(new Manifest(manifestPath, properties));
		manifest = newM;
		LibraryPtr newL(context->FindOrCreateLibrary(manifest->GetId()));
		library = newL;
	}

	public bool Install()
	{
		path installPath = getInstallPath();
		if (boost::filesystem::exists(installPath))
		{
			boost::filesystem::remove_all(installPath);
		}
		else
		{
			boost::filesystem::create_directories(installPath);
		}

		// Interface.mh - copy this file to root of directory.
		path localMhInterface(manifest->GetRootDirectory());
		localMhInterface = localMhInterface / manifest->GetMOutput();
		localMhInterface = localMhInterface / "Interface.mh";
		//path exportMhInterfaceDir(installPath);
		//exportMhInterfaceDir = exportMhInterfaceDir;
		//boost::filesystem::create_directories(exportMhInterfaceDir);
		//path exportMhInterface = exportMhInterfaceDir/ "Interface.mh";
		//boost::filesystem::copy_file(localMhInterface, exportMhInterface);

		//const Path dir(manifest->GetRootDirectory(), manifest->GetRootDirectory());
		//PathPtr genSrc = dir.NewPathForceSlash(manifest->GetMOutput());//"/GeneratedSource");		
		//PathPtr src(new Path(manifest->GetRootDirectory(), manifest->GetRootDirectory()));
		//PathPtr installPathPtr(new Path(installPath, installPath));
		BuildContextPtr iCon = createBuildContext(manifest); //(new BuildContext(library, src, genSrc, installPathPtr));
		Manifest::RunResultPtr result = manifest->RunTarget(console, iCon, "install", "Install");
		//Path::CopyDirectoryContents(headersLocal, headersInstall);
		// return true;
		if (result->Success) 
		{
			manifest->SaveAs(installPath / "manifest-final.lua", result->RunList);
		}
		return result->Success;
	}
	
	private void parseChildren(vector<LibraryId> & dependencyStack, 
							   ManifestPtr sourceManifest, 
							   LibraryPtr sourceLibrary)
	{
		const std::vector<const std::string> children = sourceManifest->GetChildren();
		BOOST_FOREACH(const string & child, children)
		{			
			
			std::vector<FileSet> input;
			input.push_back(FileSet(boost::filesystem::path(child), "\\.m(cpp|h)?$"));			
			compiler.BuildModel(sourceLibrary, input);			
		}
	}
	/** Parse the dependencies of the given manifest / library. */
	private void parseDependencies(vector<LibraryId> & dependencyStack,
								   ManifestPtr sourceManifest,
								   LibraryPtr sourceLibrary)
	{
		BOOST_FOREACH(ManifestPtr dependency, sourceManifest->GetDependencies()) 
		{
			const LibraryId id = dependency->GetId(); //TODO: Make less stupid
			dependencyStack.push_back(id);
			parseDependency(dependencyStack, sourceManifest, library, id);
			dependencyStack.pop_back();
		}
	}

	private void parseDependency(vector<LibraryId> & dependencyStack,
								 ManifestPtr sourceManifest,
								 LibraryPtr sourceLibrary, 
								 const LibraryId dependencyId)
	{
		// Load manifest of dependency, create libraries
		//const LibraryId id = dependency->GetId(); // OMG, can't believe how stupid this is.		
		ManifestPtr dManifest(new Manifest(dependencyId.FindFinalManifestFile(), properties));		
		LibraryPtr dLib = sourceLibrary->GetContext()->FindOrCreateLibrary(dManifest->GetId());
		// Now parse all of the dependency's dependencies before continuing.
		parseDependencies(dependencyStack, dManifest, dLib);		

		// Parse all of its source.
		parseManifestSource(dependencyStack, dManifest, dLib);
		
		// Run prepare phase of dependency
		BuildContextPtr iCon = createBuildContext(dManifest);
		iCon->GetOutputDir()->CreateDirectory();
		Manifest::RunResultPtr result = dManifest->RunTarget(console, iCon, "prepare", "Prepare");

		// Now, add it as a dependency of this library.
		sourceLibrary->AddDependency(dLib.get());
	}

	/** Given the manifest and library, add its Macaroni source to the Context. 
	 */
	private void parseManifestSource(vector<LibraryId> & dependencyStack, 
									 ManifestPtr sourceManifest, 
									 LibraryPtr sourceLibrary)
	{
		const std::vector<const std::string> src = sourceManifest->GetMSource();
		BOOST_FOREACH(const string & dir, src)
		{			
			std::vector<FileSet> input;
			input.push_back(FileSet(boost::filesystem::path(dir), "\\.m(cpp|h)?$"));			
			compiler.BuildModel(sourceLibrary, input);			
		}
	}

	public bool ParseMacaroniSource()
	{
		return parseManifest(manifest, library);
	}
	
	public bool parseManifest(ManifestPtr & manifest, LibraryPtr & library) 
	{
		vector<LibraryId> dependencyStack;
		dependencyStack.push_back(manifest->GetId());

		try 
		{
			console.WriteLine("~ Parsing dependencies. ~");
			parseDependencies(dependencyStack, manifest, library);
			console.WriteLine("~ Creating Macaroni model from source files (.mh, .mcpp). ~");
			parseManifestSource(dependencyStack, manifest, library);
		}
		catch(Macaroni::Exception & ex)
		{
			console.Write("An error occured in ");
			printOutDependencyStack(dependencyStack);
			console.WriteLine(".");
			console.WriteLine(ex.GetSource());
			console.WriteLine(ex.GetMessage());
			return false;
		}
		catch(Macaroni::Parser::ParserException & pe)
		{
			console.Write("An error occured parsing Macaroni code while in dependency ");
			printOutDependencyStack(dependencyStack);
			console.WriteLine(".");
			console.WriteLine(pe.GetSource()->ToString());
			console.WriteLine(pe.GetMessage());
			return false;
		}
		catch(std::exception & ex)
		{
			console.Write("An error occured in ");
			printOutDependencyStack(dependencyStack);
			console.WriteLine(".");
			console.WriteLine(ex.what());
			return false;
		}
		return true;
	/*
		


		std::string mSrc = manifest->GetMSource()[0];
		std::string mOut = manifest->GetMOutput();
		std::vector<FileSet> inputFiles;

		// Include dependencies
		BOOST_FOREACH(ManifestPtr dependency, manifest->GetDependencies()) 
		{
			parseDependency(library, compiler, dependency);
		}
		// end include dependencies

		inputFiles.push_back(FileSet(boost::filesystem::path(mSrc), "\\.mcpp$"));

		std::vector<const std::string> blankGeneratorSelection;
		MCompilerOptions options(inputFiles,
								 boost::filesystem::path(mOut),
								 blankGeneratorSelection);

		try
		{
			compiler.Compile(library, options);
		}
		catch(Macaroni::Exception & ex)
		{
			console.WriteLine("An error occured during Macaroni phase.");
			console.WriteLine(ex.GetSource());
			console.WriteLine(ex.GetMessage());
			return false;
		}
		catch(Macaroni::Parser::ParserException & pe)
		{
			console.WriteLine("Error parsing Macaroni code: ");
			console.WriteLine(pe.GetSource()->ToString());
			console.WriteLine(pe.GetMessage());
			return false;
		}
		return true;*/		
	}

	private void printOutDependencyStack(vector<LibraryId> & dependencyStack)
	{
		bool seenOne = false;
		BOOST_FOREACH(LibraryId & id, dependencyStack)
		{
			if (!seenOne) 
			{
				seenOne = true;
			}
			else 
			{
				console.Write(" -> ");
			}
			console.Write(id.GetGroup());
			console.Write("|");
			console.Write(id.GetName());
			console.Write("|");
			console.Write(id.GetVersion());
		}
	}

	/** The initial script is where system-wide settings are stored. */
	public string RunInitialScript()
	{
		path userPath(Paths::GetUserPath());
		path initLuaPath = userPath / "init.lua";		
		if (!boost::filesystem::exists(initLuaPath))
		{
			stringstream ss;
			ss	<< "Could not find init.lua at "
				<< initLuaPath 
				<< ".";
			console.WriteLine(ss.str());
			return "{}";			
		} 
		else 
		{
			LuaEnvironment env;
			env.ParseFile(initLuaPath.string());
			env.Run();
			stringstream cereal;
			env.SerializeTable(cereal, "properties");
			return cereal.str();
		}		
	}

	public bool SaveCppSource()
	{
		createCppSrcRoots();
        createCppFileList();

		path cppSourceLocal(manifest->GetCppSourceOutput());

		std::stringstream ss;
		ss << "Saving generated and non-generated C++ source code to " <<
				cppSourceLocal.string() << ".";
		console.WriteLine(ss.str());

		boost::filesystem::create_directories(cppSourceLocal);
		CopyHeaderFiles(cppSourceLocal);
		CopyCppFiles(cppSourceLocal);
		return true;
	}

};

} // end namespace

