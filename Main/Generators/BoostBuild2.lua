require "Macaroni.IO.GeneratedFileWriter";
require "Macaroni.Model.Library";
require "Macaroni.IO.Path";
require "Log"
require "Cpp/LibraryConfigGenerator";


Target = Macaroni.Model.Project.Target;

--require "Macaroni.IO.PathList";


function GetMethod(name)
    if name == "Generate" then
        return
        {
            Describe = function(args)
                validateArgs(args);
                args.output.WriteLine("Create Boost Build file for target "
                                      .. tostring(args.target)
                                      .. "to the directory "
                                      .. tostring(args.path) .. ".");
            end,
            Run = function(args)
                validateArgs(args);
                local target = args.target;
                Build(args.target, args.sources, args.outputPath, nil, args)
                ibrary, sources, outputPath, installPath, extraArgs)
                Generate(args.target, args.path)
            end
        }
    end
    return nil;
end




-------------------------------------------------------------------------------
-- Create jamroot.jam at args.jamrootPath.
--
-------------------------------------------------------------------------------

function validateArgs(self)
    Plugin.Check(self.target ~= nil, "Missing argument 'target'.")
    Plugin.Check(self.jamroot ~= nil, "Missing argument 'jamroot'.")
    self.Log == self.Log or Plugin.CreateFakeLog()
end

function includePaths(target)
    -- Print out the include paths for a target.
    local t = {};
    for header in Plugin.IterateFiles(target.Sources.Headers) then
        t[#t + 1] = "<include>\"" .. header.Path.AbsolutePath .. "\""
    end
    p
    if target.Sources.Headers ~= nil then
        t[#t + 1] = target.Sources.Headers
    end
    t[# + 1] = target.Sources["headers"]
    return table.concat(t, "\n\t");

    <include>./
        <include>"F:/Work/Lp3/Projects/Macaroni/Code/trunk/Tests/Features/BoostBuild/SomeLibB/Source"
        <include>"F:/Tools/boost_1_46_1"
end

function writeBoostFile(self)
    local buildjam = outputPath:NewPath("/jamroot.jam");
    log:Write("Creating Boost.Build file at " .. buildjam.AbsolutePathForceSlash .. ".");
    self.output:WriteLine("Creating Jamroot file at " .. tostring(buildJam)
                          .. ".");
    local writer = buildjam:CreateFile();

    writer:WriteLine([[
# Generated by Macaroni.
# ~~ Library Info ~~
# Group   : ]] .. self.target.ProjectVersion.Group.Name ..
[[# Name    : ]] .. self.target.ProjectVersion.Project.Name ..
[[# Version : ]] .. self.target.ProjectVersion.Version ..
[[
import boost ;
import path ;
using testing ;

project ]] .. self.target:GetCId() ..
[[
    :   usage-requirements
        <link>shared:<define>]] .. LibraryDynLink(self.target) .. [[=1
        ]] .. includePaths(self.target) .. [[

    ;

alias library_dependencies
    :    ;

alias library_sources
    :   [ glob-tree *.c : .svn *Test.cpp ]
        [ glob-tree *.cpp : .svn *Test.cpp ]
        [ path.glob-tree "F:/Work/Lp3/Projects/Macaroni/Code/trunk/Tests/Features/BoostBuild/SomeLibB/Source/" : *.c : .svn *Test.cpp ]
        [ path.glob-tree "F:/Work/Lp3/Projects/Macaroni/Code/trunk/Tests/Features/BoostBuild/SomeLibB/Source/" : *.cpp : .svn *Test.cpp ]
        ;

lib MACARONI_LIB_TARGET_Macaroni___Macaroni_46_Tests_46_Features_46_BoostBuildSomeLibB  :   library_dependencies
        library_sources
    :   <link>shared:<define>MACARONI_LIB_DYN_LINK_Macaroni___Macaroni_46_Tests_46_Features_46_BoostBuildSomeLibB=1
            :   # '_' ?!
    :       ;

alias library : MACARONI_LIB_TARGET_Macaroni___Macaroni_46_Tests_46_Features_46_BoostBuildSomeLibB  ;

alias test_dependencies
            : "F:/Tools/boost_1_46_1/libs/test/build//boost_unit_test_framework"
            :
            ;

# Tests

# Extra targets specified in Macaroni manifest:

]])

    writer:Close();
end

function boostSystemProperties()
    if (properties.boost ~= nil and properties.boost.current ~= nil) then
        local bprops = properties.boost.current;
        return bprops;
    end
    return nil;
end

function createDependencyList(library)
    local rtn = {};
    local deps = library.Dependencies;
    for k, v in pairs(deps) do
        local dep = v;
        local jamDir = dependencyJamDir(v);
        if (jamDir ~= nil) then
            local element = { };
            element.jamDir = jamDir.AbsolutePathForceSlash;
            element.name = createProjectName(dep);
            rtn[#rtn + 1] = element;
        end
    end
    return rtn;
end

function initializeExtraArgs(args)
    args = args or {}
    args.excludePattern = args.ExcludePattern or ".svn";
    args.extraTargets = args.ExtraTargets or "";
    args.libraryRequirements = args.LibraryRequirements or "";
    args.tests = args.Tests or {};
    return args;
end

function Build(library, sources, outputPath, installPath, extraArgs)
    log.Init("BoostBuild");
    local excludePattern;
    local args = initializeExtraArgs(extraArgs);
    createJamroot(library, sources, outputPath, args.excludePattern,
                  args.extraTargets, args.libraryRequirements, args.tests);

    local cmdLine = "bjam "
    if extraArgs.Link ~= nil then
        cmdLine = cmdLine .. "link=" .. extraArgs.Link;
    end
    if (extraArgs.CmdLine ~= nil) then
        cmdLine = cmdLine .. " " .. extraArgs.CmdLine
    end
    cmdLine = cmdLine .. " " ..  outputPath.AbsolutePathForceSlash
    print(cmdLine)
    local rtnCode = os.execute(cmdLine)
    log:Write("BJAM return code = " .. rtnCode .. ".")
    if (rtnCode ~= 0) then
        error("Call to Boost.Build failed.")
        return false;
    end
end

function Test(library, sources, outputPath, installPath, extraArgs)
    log.Init("BoostBuild");
    local cmdLine = "bjam"
    if (extraArgs.CmdLine ~= nil) then
        cmdLine = cmdLine .. " " .. extraArgs.CmdLine
    end
    cmdLine = cmdLine .. " " ..  outputPath.AbsolutePathForceSlash
    print(cmdLine)
    local rtnCode = os.execute(cmdLine)
    log:Write("BJAM return code = " .. rtnCode .. ".")
    if (rtnCode ~= 0) then
        error("Call to Boost.Build failed.")
        return false;
    end
end

function findFilePath(sources, file)
    -- Given a series of directories, finds the file... if such a file exists!
    for i, v in ipairs(sources) do
        local fullPath = v:NewPathForceSlash(file)
        if fullPath.Exists then
            return fullPath.GetAbsolutePathForceSlash;
        end
    end
    return nil;
end

function createJamroot(library, sources, outputPath, excludePattern,
                       extraTargets, libraryRequirements, tests)
    local buildjam = outputPath:NewPath("/jamroot.jam");
    log:Write("Creating Boost.Build file at " .. buildjam.AbsolutePathForceSlash .. ".");

    local writer = buildjam:CreateFile();

    local forAllSourcesWrite = function(text)
        -- Because this gets generated to the output path, a relative path will
        -- work.
         -- writer:Write(text('./')); -- outputPath.AbsolutePathForceSlash));
        -- ^- Actually, NO, you can't do this, thanks to yet another undocumented
        -- "feature" of Boost.Build.  If you use "path.glob-tree" with a
        -- relative path being the source directory, will first off the code
        -- above is wrong because it generates ".//" which means Boost just
        -- ignores it.  But when I changed it to "./" suddenly Boost started
        -- trying to include targets from the calling project (this occured
        -- when trying to use Lua as a dependency with a generated Jamroot)!
        -- So instead you have to use the vanilla "glob-tree" to avoid
        -- this unexplained behavior.  Of course, maybe this means *ANY* use
        -- of "path.glob-tree" is doomed to failure if its in a project that
        -- is being referenced by another project! Wonderful!!
        -- Spend hours figuring this out.
        for i = 1, #sources do
            local source = sources[i];
            writer:Write(text(source.AbsolutePathForceSlash));
        end
    end;

    local pDeps = createDependencyList(library);

    writer:Write([[
# Generated by Macaroni.
# ~~ Library Info ~~
# Group   : ]] .. library.Group .. "\n" .. [[
# Name    : ]] .. library.Name .. "\n" .. [[
# Version : ]] .. library.Version .. "\n" .. [[

import boost ;
import path ;
using testing ;

]]);

    for k, v in pairs(pDeps) do
        writer:Write("use-project /" .. v.name .. [[ : "]] .. v.jamDir .. [[" ; ]] .. "\n");
    end
    -- log:WriteDependencyProjectIncludes(writer, library);
    writer:Write([[
project ]] .. createProjectName(library) .. "\n" .. [[
    :   usage-requirements
        <link>shared:<define>]] .. LibraryDynLink(library) .. [[=1
        <link>static:<define>]] .. createProjectDef(library) .. [[_STATIC_LINK=1  # <-- This is stupid and doesn't do anything right now. ^_^
]]);
    writer:Write("\t\t<include>./ \n");
    forAllSourcesWrite(function(src) return "\t\t" .. [[<include>"]] .. src .. [["]] .. " \n"; end);

    local boostProps = boostSystemProperties();
    if (boostProps ~= nil) then
        writer:Write("\t\t" .. [[<include>"]] .. boostProps.include .. [["]] .. " \n");
    end

    for k, v in pairs(pDeps) do
        writer:Write("\t\t<dependency>/" .. v.name .. "//library\n");
    end

    writer:Write([[
    ;

alias library_dependencies
    :   ]]);
    for k, v in pairs(pDeps) do
        writer:Write("/" .. v.name .. "//library\n\t\t");
    end
    writer:Write([[ ;

alias library_sources
    :   ]]);
    writer:Write("[ glob-tree *.c : " .. excludePattern .. " ]\n\t\t"
                .. "[ glob-tree *.cpp : " .. excludePattern .. " ]\n\t\t");
    forAllSourcesWrite(function(src) return
        [[[ path.glob-tree "]] .. src .. [[/" : *.c : ]] .. excludePattern .. " ]\n\t\t" ..
        [[[ path.glob-tree "]] .. src .. [[/" : *.cpp : ]] .. excludePattern .. " ]\n\t\t";
        end);
    --for k, v in pairs(library.Dependencies) do
    --  local jamDir = dependencyJamDir(v);
    --  if (jamDir ~= nil) then
    --      writer:Write([["]] .. jamDir.AbsolutePathForceSlash .. [[//libSources" ]]);
    --  end
    --end
    -- writer:Write(" : ");
    -- writer:Write([[ <include>./ ]]);
    --forAllSourcesWrite(function(src) return [[
    --  <include>"]] .. src .. [["
    --  ]]; end);
    writer:Write(";\n" .. [[

lib ]] .. LibraryMetaTarget(library) .. [[
    :   library_dependencies
        library_sources
    :   <link>shared:<define>]] .. LibraryDynLink(library) .. [[=1
        ]] .. libraryRequirements .. [[
    :   # '_' ?!
    :   ]]);
    first = true
    for k, v in pairs(pDeps) do
        if first then
            first = false
        else
            writer:Write("      ");
        end
        writer:Write("<link>shared:<library>\"" .. v.jamDir .. "\"//library \n");
    end
    writer:Write([[
    ;

alias library : ]] .. LibraryMetaTarget(library) .. [[  ;

alias test_dependencies
            : "]] .. properties.boost.current["path"]
                  .. [[/libs/test/build//boost_unit_test_framework"
            :
            ;

# Tests]] .. '\n');

    --Have to hack this because right now tests cannot be passed as an array. :(
    for i, v in ipairs(tests) do
        local testFilePath = findFilePath(sources, v);
        if testFilePath == nil then
            error([[The test file ]] .. v
                  .. [[ could not be found in any of the sources.]]);
        end
        writer:Write([[
        unit-test __test]] .. tostring(i) .. '\n' .. [[
            : library
              test_dependencies
              "]] .. testFilePath .. [["
            ;
        ]]);
    end

    writer:Write([[

# Extra targets specified in Macaroni manifest:]] .. "\n");
    -- I don't think I should put this junk in there anymore...
    --for k, v in pairs(library.Dependencies) do
    --  if (dependencyJamDir(v) ~= nil) then
    --      writer:Write([[<use>/]] .. createProjectName(v) .. [[//library ]]);
    --  end
    --end
    --writer:Write([[
    --: ]]);
    --for k, v in pairs(library.Dependencies) do
    --  if (dependencyJamDir(v) ~= nil) then
    --      writer:Write([[<library>/]] .. createProjectName(v) .. [[//library ]]);
    --  end
    --end
    --writer:Write([[
    --;
    --]]);
    writer:Write(extraTargets);
    writer:Close();

end

function createProjectDef(library)
    return "MACARONI_LIB_" .. createProjectName(library);
end

function createProjectName(library)
    return cleanUpName(library.Group) .. "____"
        .. cleanUpName(library.Name) .. "____"
        .. cleanUpName(library.Version);
end

function cleanUpName(str)
    return string.gsub(str, "_", "_u").gsub(str, " ", "_s");
end

function dependencyJamDir(d)
    local success, path = pcall(d.FindInstallPath, d);
    if (success and path ~= nil) then
        local pathText = path.AbsolutePathForceSlash;
        local jamroot = path:NewPathForceSlash('Cpp/jamroot.jam');
        if (jamroot.Exists) then
            return path:NewPathForceSlash('Cpp');
        end
    end
    return nil;
end

function Install(library, sourcePaths, outputPath, installPath, extraArgs)
    log.Init("BoostBuild");
    -- Create a Jam file which simply points to the source files.
    -- Copy all C++ source to the folder.
    local dstPath = installPath:NewPathForceSlash("Cpp");
    local patterns = {[[\.c(pp)?$]], [[\.h(pp)?$]]}
    local paths = sourcePaths
    for k,pattern in ipairs(patterns) do
        for i = 0, #sourcePaths do
            local path;
            if (i == 0) then
                path = outputPath;
            else
                path = sourcePaths[i];
            end
            copyCppSource(pattern, path, dstPath);
        end
    end


    --local iJam = dstPath:NewPathForceSlash('jamroot.jam');
    --local writer = iJam:CreateFile();
    --writer:Write([[
    --# Generated by Macaroni
    --
    --]]);
    --writer:Close();
    local args = initializeExtraArgs(extraArgs);
    createJamroot(library, {}, dstPath, args.excludePattern, args.extraTargets,
                  args.libraryRequirements, {});

    return nil; --{ mario = "One good game." };
end

-- Copy all .C, .CPP, .H and .HPP files to dir.=
function copyCppSource(regEx, src, dst)
    local srcs = src:GetPaths(regEx);
    for i = 1, #srcs do
        local child = srcs[i];
        if (not child.IsDirectory) then
            log:Write(tostring(child.AbsolutePathForceSlash) .. " ... " .. tostring(dst.AbsolutePathForceSlash));
            --src:CreateDirectory();
            child:CopyToDifferentRootPath(dst);
        else
            -- May not be necessary
            -- iterateDir(regEx, child, dst);
        end
    end
end

function Prepare(library, sourcePaths, outputPath, installPath, extraArgs)
end

function printDependencyProjectIncludes(writer, library)
    writer:Write([[
# Dependencies, in the form of Boost Build projects. ]]);
    local deps = library.Dependencies;
    writer:Write("# There are " .. #deps .. " dependencies.\n");
    for k, v in pairs(deps) do
        local dep = v;
        local jamDir = dependencyJamDir(v);
        writer:Write("# " .. dep.Group .. " // " .. dep.Name .. "//" .. dep.Version .. "\n");
        if (jamDir == nil) then
            writer:Write("# nil\n");
        else
            writer:Write("use-project /" .. createProjectName(dep)
                .. " : \"" .. jamDir.AbsolutePathForceSlash .. "\" ;\n");
        end
    end
end
