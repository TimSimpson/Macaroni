require "string"
require "Macaroni.Core.Hash";
require "Macaroni.IO.GeneratedFileWriter";
require "Macaroni.Model.Library";
require "Macaroni.IO.Path";
require "Log"
require "Cpp/LibraryConfigGenerator";
require "Plugin"

Hash = Macaroni.Core.Hash

Target = Macaroni.Model.Project.Target;

--require "Macaroni.IO.PathList";


function GetMethod(name)
    if name == "Generate" then
        return
        {
            Describe = function(args)
                validateArgs(args);
                args.output.WriteLine("Create CMake file for project "
                                      .. tostring(args.projectVersion)
                                      .. "to the directory "
                                      .. tostring(args.path) .. ".");
            end,
            Run = function(args)
                validateArgs(args);
                Initialize(args);
                Generate(args)
            end
        }
    else
        error('Unknown method "' .. tostring(name) .. '".')
    end
    return nil;
end

function validateArgs(self)
    Plugin.Check(self.projectVersion ~= nil, "Missing argument 'projectVersion'.")
    Plugin.Check(self.output ~= nil, "Missing argument 'output'.")
    Plugin.Check(self.filePath ~= nil, "Missing argument 'filePath'.")
end


function Initialize(self)
    self.cid = self.projectVersion:GetCId()
end


function Generate(self)
    validateArgs(self)
    Initialize(self)
    writeCMakeFile(self)
end

function writeCMakeFile(self)
    local writer = self.filePath:CreateFile();

    writer:WriteLine([[
# Generated by Macaroni.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~ Library Info ~~
# Group   : ]] .. self.projectVersion.Project.Group.Name .. '\n' ..[[
# Name    : ]] .. self.projectVersion.Project.Name .. '\n' .. [[
# Version : ]] .. self.projectVersion.Version .. '\n' .. [[
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cmake_minimum_required (VERSION 2.6)
project (]] .. self.projectVersion.Project.Name .. [[)
        ]]);

    writeLibraries(self, writer)
    writeExes(self, writer)
end

function cmakeName(self, target)
    -- Given a target, finds the name CMake knows it by in this file.
    if target.TypeName == "lib" then
        return target.ShortName;
    elseif target.TypeName == "unit" then
        if target.CppFile ~= nil then
            return target.CppFile.AbsolutePathForceSlash
        end
    end
    -- Stand by option:
    return target:GetCId();
end

function hasCMakeSupport(self, target)
    if target.TypeName == "lib"
       and target.ProjectVersion:GetCId() ~= self.cid then
        return true
    else
        return true
    end
end

function includeDirectoriesOfTarget(self, target)
    -- Returns a string for use in the jam file which contains include paths
    -- for all necessary headers.
    local t = {};
    if target.Headers ~= nil then
        for header in Plugin.IterateFiles(target.Headers) do
            t[#t + 1] = "\"" .. header.AbsolutePathForceSlash .. "\""
        end
    end
    return table.concat(t, "\n        ");
end


function writeIncludeDirectories(self, writer, target)
    local deps = allTargetDependencies(self, target)
    deps[#deps + 1] = target

    writer:WriteLine([[
include_directories (]]);
    for i, target in ipairs(deps) do
        writer:WriteLine("          "
                         .. includeDirectoriesOfTarget(self, target))
    end
    writer:WriteLine([[
) ]]);
end

function writeLibraries(self, writer)
    for target in Plugin.IterateProjectVersionTargets(self.projectVersion,
                                                      "lib")
    do
        writeLibrary(self, writer, target)
    end
end

function writeLibrary(self, writer, library)
    writeIncludeDirectories(self, writer, library)
    writer:WriteLine([[
add_library(]] .. cmakeName(self, library) .. [[
        ]] .. cmakeDependencyList(self, library) .. [[
        )
    ]]);
end

function allTargetDependencies(self, target, filter)
    -- Returns a string with all a targets with jam support seperated by spaces
    local t = {};
    for target in Plugin.IterateDependencies(target) do
        if not filter or filter(target) then
            if target.TypeName == 'unit' or
                hasCMakeSupport(self, target) then
                t[#t + 1] = target
            end
        end
    end
    return t
end


function cmakeDependencyList(self, target, filter)
    local deps = allTargetDependencies(self, target, filter)
    local t = {};
    for i, target in ipairs(deps) do
        if target ~= nil then
            t[#t + 1] = cmakeName(self, target)
        end
    end
    return table.concat(t, "\n        ");
end

function writeExes(self, writer)
    for target in Plugin.IterateProjectVersionTargets(self.projectVersion,
                                                      "exe")
    do
        writeExe(self, writer, target)
    end
end

function writeExe(self, writer, exeTarget)
    local notLib = function(target)
        return target.TypeName ~= "lib"
    end
    writeIncludeDirectories(self, writer, exeTarget)
    writer:WriteLine([[
add_executable(]] .. cmakeName(self, exeTarget) .. [[
        ]] .. cmakeDependencyList(self, exeTarget, notLib) .. [[
        )
    ]]);

    local isLib = function(target)
        return target.TypeName == "lib"
    end

    local deps = allTargetDependencies(self, exeTarget, isLib)
    for i, depTarget in ipairs(deps) do
        writer:WriteLine("target_link_libraries("
            .. cmakeName(self, exeTarget) .. " "
            .. cmakeName(self, depTarget) .. ")")
    end
end
