-- CMake support. Yay!
--
-- Notes:
-- How to build just in the target directory:
-- cmake target/CMakeLists.txt -Btarget
-- make -C ./target install
--
-- http://www.cmake.org/Wiki/CMake/Tutorials/Exporting_and_Importing_Targets
--
-- http://stackoverflow.com/questions/8774593/cmake-link-to-external-library
-- http://www.cmake.org/Wiki/CMake:How_To_Find_Libraries
-- http://www.cmake.org/cmake/help/cmake_tutorial.html

require "string"
require "Macaroni.Core.Hash";
require "Macaroni.IO.GeneratedFileWriter";
require "Macaroni.Model.Library";
require "Macaroni.IO.Path";
require "Log"
require "Cpp/LibraryConfigGenerator";
require "Plugin"

Hash = Macaroni.Core.Hash

Target = Macaroni.Model.Project.Target;

--require "Macaroni.IO.PathList";


function GetMethod(name)
    if name == "Generate" then
        return
        {
            Describe = function(args)
                validateArgs(args);
                args.output.WriteLine("Create CMake file for project "
                                      .. tostring(args.projectVersion)
                                      .. "to the directory "
                                      .. tostring(args.path) .. ".");
            end,
            Run = function(args)
                validateArgs(args);
                Initialize(args);
                Generate(args)
            end
        }
    else
        error('Unknown method "' .. tostring(name) .. '".')
    end
    return nil;
end

function validateArgs(self)
    Plugin.Check(self.projectVersion ~= nil, "Missing argument 'projectVersion'.")
    Plugin.Check(self.output ~= nil, "Missing argument 'output'.")
    Plugin.Check(self.filePath ~= nil, "Missing argument 'filePath'.")
end


function Initialize(self)
    self.cid = self.projectVersion:GetCId()
    self.cmakeFiles = {}
    self.installTargets = {}
end


function Generate(self)
    validateArgs(self)
    Initialize(self)
    writeCMakeFile(self)
end

function writeCMakeFile(self)
    local writer = self.filePath:CreateFile();

    writer:WriteLine([[
# Generated by Macaroni.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~ Library Info ~~
# Group   : ]] .. self.projectVersion.Project.Group.Name .. '\n' ..[[
# Name    : ]] .. self.projectVersion.Project.Name .. '\n' .. [[
# Version : ]] .. self.projectVersion.Version .. '\n' .. [[
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cmake_minimum_required (VERSION 2.6)
project (]] .. self.projectVersion.Project.Name .. [[)
        ]]);

    writeLibraries(self, writer)
    writeExes(self, writer)

--     writer:WriteLine([[install(
--         EXPORT cmake-interface
--         DESTINATION ${CMAKE_CURRENT_BINARY_DIR}
-- )]]);
    writer:Write([[export(TARGETS ]] .. "\n        ");
    for i, t in ipairs(self.installTargets) do
        writer:Write(t .. " ");
    end
    writer:WriteLine([[ FILE cmake-interface.cmake) ]]);
end

function cmakeName(self, target)
    -- Given a target, finds the name CMake knows it by in this file.
    if target.TypeName == "lib" or target.TypeName == "exe" then
        if target.ShortName then
            return target.ShortName;
        end
    elseif target.TypeName == "unit" then
        if target.CppFile ~= nil then
            return target.CppFile.AbsolutePathForceSlash
        end
    end
    -- Stand by option:
    return target:GetCId();
end


function findCMakeInterfaceFile(self, target)
    local cachedResult = self.cmakeFiles[target:GetCId()]
    if cachedResult ~= nil then
        return cachedResult
    end
    local success, path = pcall(target.FindInstallPath, target);
    if (success and path ~= nil) then
        local pathText = path.AbsolutePathForceSlash;
        local cmakeFile = path:NewPathForceSlash('target/cmake-interface.cmake');
        if (cmakeFile.Exists) then
            self.cmakeFiles[target:GetCId()] = cmakeFile
            return cmakeFile
        end
    end
    self.cmakeFiles[target:GetCId()] = false
    return nil;
end


function hasCMakeSupport(self, target)
    if target.TypeName == "lib"
       and target.ProjectVersion:GetCId() ~= self.cid
       and (not findCMakeInterfaceFile(self, target)) then
        return false
    end
    return true
end

function includeDirectoriesOfTarget(self, target)
    -- Returns a string for use in the jam file which contains include paths
    -- for all necessary headers.
    local t = {};
    if target.Headers ~= nil then
        for header in Plugin.IterateFiles(target.Headers) do
            t[#t + 1] = "\"" .. header.AbsolutePathForceSlash .. "\""
        end
    end
    return table.concat(t, "\n        ");
end


function writeIncludeDirectories(self, writer, target)
    local deps = allTargetDependencies(self, target)
    deps[#deps + 1] = target

    writer:WriteLine([[
include_directories (]]);
    for i, target in ipairs(deps) do
        writer:WriteLine("          "
                         .. includeDirectoriesOfTarget(self, target))
    end
    writer:WriteLine([[
) ]]);
end

function writeLibraries(self, writer)
    for target in Plugin.IterateProjectVersionTargets(self.projectVersion,
                                                      "lib")
    do
        writeLibrary(self, writer, target)
    end
end

function writeLibrary(self, writer, library)
    local hasLibSupport = function(target)
        return target ~= nil and hasCMakeSupport(self, target)
    end
    writeIncludeDirectories(self, writer, library)
    writer:WriteLine([[
add_library(]] .. cmakeName(self, library) .. [[
        ]] .. cmakeDependencyList(self, library, hasLibSupport) .. [[
        )
    ]]);
    -- writer:WriteLine([[install(TARGETS ]] .. cmakeName(self, library)
    --     .. [[ DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/exe ]]
    --     .. [[ EXPORT cmake-interface )]]);
    self.installTargets[#self.installTargets + 1] = cmakeName(self, library)
    -- writer:WriteLine([[export(TARGETS ]]
    --     ..  cmakeName(self, library) .. [[ FILE cmake-interface.cmake) ]]);
end

function allTargetDependencies(self, target, filter)
    -- Returns a string with all a targets with jam support seperated by spaces
    local t = {};
    for target in Plugin.IterateDependencies(target) do
        if not filter or filter(target) then
            t[#t + 1] = target
        end
    end
    return t
end


function cmakeDependencyList(self, target, filter)
    local deps = allTargetDependencies(self, target, filter)
    local t = {};
    for i, target in ipairs(deps) do
        if target ~= nil then
            t[#t + 1] = cmakeName(self, target)
        end
    end
    return table.concat(t, "\n        ");
end

function writeExes(self, writer)
    for target in Plugin.IterateProjectVersionTargets(self.projectVersion,
                                                      "exe")
    do
        writeExe(self, writer, target)
    end
end

function writeExe(self, writer, exeTarget)
    local notLib = function(target)
        return target.TypeName ~= "lib"
    end
    writeIncludeDirectories(self, writer, exeTarget)
    writer:WriteLine([[
add_executable(]] .. cmakeName(self, exeTarget) .. [[
        ]] .. cmakeDependencyList(self, exeTarget, notLib) .. [[
        )
    ]]);

    local isLib = function(target)
        return target.TypeName == "lib"
    end

    local deps = allTargetDependencies(self, exeTarget, isLib)
    for i, depTarget in ipairs(deps) do
        writer:WriteLine("target_link_libraries("
            .. cmakeName(self, exeTarget) .. " "
            .. cmakeName(self, depTarget) .. ")")
    end

    -- writer:WriteLine([[install(TARGETS ]] .. cmakeName(self, exeTarget)
    --     .. [[ DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/exe ]]
    --     .. [[ EXPORT cmake-interface )]]);
    -- writer:WriteLine([[export(TARGETS ]]
    --     ..  cmakeName(self, exeTarget) .. [[ FILE cmake-interface.cmake) ]]);
    self.installTargets[#self.installTargets + 1] = cmakeName(self, exeTarget)
end
