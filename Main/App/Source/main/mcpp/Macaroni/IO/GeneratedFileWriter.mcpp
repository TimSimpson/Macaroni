/**
 * Copyright 2011 Tim Simpson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
~import boost::filesystem::create_directories;
~import Macaroni::Exception;
~import Macaroni::IO::GeneratedFileWriter;
~import Macaroni::Lua::LuaClass;
~import Macaroni::Lua::LuaFunction;
~import Macaroni::Lua::LuaOperator;
~import std::ofstream;
~import std::ifstream;
~import std::ostream;
~import boost::filesystem::path;
~import boost::shared_ptr;
~import std::string;
~import std::stringstream;

namespace Macaroni::IO 
{

typedef shared_ptr<ostream> ostreamptr;
typedef shared_ptr<GeneratedFileWriter> GeneratedFileWriterPtr
	@LuaClass [ SameAsNode = GeneratedFileWriter ]
;

class GeneratedFileWriter
	@LuaClass [ ReferenceType = GeneratedFileWriterPtr ]
{
	//TODO: Move to outside of class def. due to bug in Macaroni.
	//Fix bug and move back!
	//typedef shared_ptr<ostream> ostreamptr;

	bool closed;
	bool directToFile;
	const path filePath;	
	bool fileWasWritten;
	ostreamptr writer;	

	public GeneratedFileWriter(const path filePath)
	:	closed(false), filePath(filePath), fileWasWritten(false), writer()
	{
		path parent = filePath.parent_path();
		if (!boost::filesystem::exists(parent))
		{
			boost::filesystem::create_directories(parent);
		}

		if (boost::filesystem::exists(filePath)) 
		{
			if (!boost::filesystem::is_regular(filePath))
			{
				stringstream msg;
                msg << "Cannot create GeneratedFileWriter for " << filePath.string()
					<< ": the file exists and it is non-regular.";
				throw Macaroni::Exception(msg.str().c_str());
			}
			writer = ostreamptr(new stringstream());
			directToFile = false;
		}
		else
		{
			writer = ostreamptr(new ofstream(filePath.string().c_str(), ofstream::trunc));
			directToFile = true;
		}
	}

	public ~GeneratedFileWriter()
	{
		Close();
	}

	public bool Close()
		@LuaFunction "Close"
	{
		if (!closed) 
		{
			if (directToFile) 
			{
				(dynamic_cast<ofstream *>(writer.get()))->close();
				fileWasWritten = true;
			}
			else
			{
				stringstream & ss = dynamic_cast<stringstream &>(
					*(dynamic_cast<stringstream *>(writer.get()))
					);
				fileWasWritten = overwriteFileWithBufferIfDifferent(filePath, ss);
			}
			closed = true;
		}
		return fileWasWritten;
	}

	public inline const path & GetFilePath() const
	{
		return filePath;
	}

	public static bool isFileDifferentThanBuffer(const path & filePath, stringstream & current)
	{
		char buf1[256];
		char buf2[256];
		
		ifstream existing(filePath.string().c_str());
		current.seekg(std::ios_base::beg);

		bool eof = false;
		while(!eof)
		{
			existing.read(buf1, 256);
			current.read(buf2, 256);
			if (existing.gcount() != current.gcount())
			{
				return true;
			}
			else if (existing.gcount() != 256)
			{
				eof = true;
			}
			if (strncmp(buf1, buf2, existing.gcount()) != 0)
			{
				return true;
			}
		}
		return false;
	}

	public static bool overwriteFileWithBufferIfDifferent(const path & filePath, stringstream & current)
	{
		if (!isFileDifferentThanBuffer(filePath, current))
		{
			return false;
		}
		current.seekg(std::ios_base::beg);
		ofstream output(filePath.string().c_str(), ofstream::trunc);
		output << current.str() ;
		output.close();
		return true;
	}

	public std::string ToString() const
		@LuaOperator "__tostring"
	{
		std::stringstream ss;
		ss << "GeneratedFileWriter [" << GetFilePath().string() << "]";
		return ss.str();
	}

	public void Write(const std::string & text)
		@LuaFunction "Write"
	{
		(*writer) << text;
	}

	public void WriteLine(const std::string & text)
		@LuaFunction "WriteLine"
	{
		(*writer) << text << std::endl;
	}
};

} // end namespace