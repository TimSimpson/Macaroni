/**
 * Copyright 2011 Tim Simpson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef MACARONI_PARSER_CPP_GENERAL_SPIRIT
#define MACARONI_PARSER_CPP_GENERAL_SPIRIT

#include <boost/spirit/core.hpp>
#include <boost/spirit/actor/push_back_actor.hpp>
#include <boost/spirit/utility/confix.hpp>
#include <boost/spirit/utility/chset.hpp>

using namespace boost::spirit;
/** It is insanity to try to avoid using the boost::spirit namespace; all of the
 * code would become unreadable.  I think making an alias for the namespace is
 * nearly as bad as including it, plus you'd still get unreadable parser
 * definitions.
 * So the alternative is to simply put all the parsing rules in these ".spirit"
 * files and make sure they are only included from .CPP files.
 */

// Have to define in order of use so I can't alphabetize! NOOOOOO!
template <typename ScannerT>
struct General
{	
	General()
	{
		braceL = ch_p('{');
		braceR 
			=	ch_p('}');
		colon
			=	ch_p(':');
		digit
			=	range_p('0','9');	
		namespaceSeperator
			=	str_p("::");	
		nondigit
			=	range_p('a','z') | range_p('A','Z') | ch_p('_');
		semicolon
			=	ch_p(';');
		
		// Keywords:
		classKeyword 
			=	str_p("class");	
		importKeyword
			=	str_p("import");
		namespaceKeyword 
			=	str_p("namespace");
		privateKeyword
			=	str_p("private");
		protectedKeyword
			=	str_p("protected");
		publicKeyword
			=	str_p("public");
		
		// Aliases
		accessKeyword
			=	(publicKeyword | privateKeyword | protectedKeyword);				
		// Sections of stuff (comments, brace blocks, etc)
		braceSandwhich 
			=	braceL 
				>> 
				*(
					braceSandwhich 
					| 
					~ch_p('}')
				) 
				>> 
				braceR;		
		commentBlockNormal
			=	comment_p("//") 
				| 
				comment_p("/*", "*/");
		cppIdentifier
			= 	(+nondigit) | *(digit | nondigit);
		/** Like a normal identifier but can be nested using ::. */
		complexIdentifier
			=	General::cppIdentifier
				>>
				*(General::namespaceSeperator >> General::cppIdentifier);
		
			
		// More complex bits
		commentBlock
			= commentBlockNormal;	
		
	}
	
	rule<ScannerT>
		braceL,
		braceR,
		colon,
		digit,
		namespaceSeperator,
		nondigit,
		semicolon,
		classKeyword,
		importKeyword,
		namespaceKeyword,
		privateKeyword,
		protectedKeyword,
		publicKeyword,
		accessKeyword,
		braceSandwhich,
		commentBlockNormal,
		cppIdentifier,
		complexIdentifier,
		commentBlock;
};

#endif