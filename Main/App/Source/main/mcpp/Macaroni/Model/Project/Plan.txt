Group

* Project

* * Project Version

* * * Variant

* * * Target


Task

Condition


THE GOAL: Create the data only model first. Think about the idea of a general
task system, but don't do it yet. Try to make the model flexible enough that
it can drive the creation of BJAM and Visual Studio files.


padding-top: 20px;

Group:
	Name
	Projects()

Project:
	Name,
	Versions()

Project Version:
	Name,
	Targets

Target: -> Task
	Dependencies()


Object File:
	Source - a single C++ file.

Library:  -> Target
	Sources - A list of sources, MCPP and C++.
		Using annotations you can put Macaroni nodes into a Library.
		All C++ files generated then become part of that Library.

Exe: -> Target
	This creates an executable.
	Sources- list of sources
	Exe name

Test: -> Target
	Like an EXE but produces a file or something.
	Sources - Makes up an exe.


Sources - a list of files, C++ and Macaroni, as well as targets.
	For example, the EXEs include libraries in the sources.



Example (in Lua):

-- "context" and "output" are the only variables automatically inserted.
-- All internal modules are required automatically.

require "Macaroni.Model.Context";
require "Macaroni.Model.Project.Group"
require "Macaroni.Model.Project.Library"
require "Macaroni.Model.Project.Project"
require "Macaroni.Model.Project.ProjectVersion"
require "Macaroni.Model.Project.Test"

local regex = context:LoadProject("Macaroni", "Boost-regex", "1.46.1");
local lua = context:LoadProject("Macaroni, Lua", "5.1.4");

local project = context:Group("Lp3"):Project("Lp3::Core"):Version("1.3")


project:Targets:Add()

-- Thought: Maybe the targets don't even need to know what Project they're in?

lib = project:Library{name="lib",
                      dependencies={ lua, regex },
                      sources= {FileSet("src/main/**/*.cpp"),
                                FileSet("src/main/**/*.mcpp")}}

-- Projects, when loaded, get their targets added via Lua. This includes
-- source code information.
-- When targets are loaded, the Macaroni parser turns on and parses whatever
-- it needs to.
-- Because dependencies must be specified when creating a library we can be
-- assured that the necessary forward references have already happened.
-- When a target loads source, every Node is associated with the target
-- automatically. But using annotations and potentially other syntax tricks
-- it is also possible for the parser to identify some nodes as belonging to
-- new targets on the fly.
-- Because these targets are defined on command they can't have their
-- dependencies specified. To make these work,

-- When "mcpp" files are discovered, the Model is parsed for nodes which were
-- created from those files. These nodes are then annotated as belonging to
-- given target.

test1 = Test{name="test1", sources = { lib, File("src/test/test1.cpp")} }

-- exe doesn't use test1 in its sources but still requires on it.
-- The sources are also required.
exe = Exe{name="main", sources={lib, test1, File("src/main/main.cpp")},
          dependsOn={test1}}

project:Targets:Add{lib, test1, exe}


FileSet = Macaroni.IO.FileSet
fs = FileSet.Create("F:\Work\")

Each Node is linked to their Target. They have a pointer to their target as
well as their source.

Each target therefore has a list of typical source files.
There are MCPP files and generated source files.
To do things like generate Visual Studio project files both are needed.






When a target is loaded an already built, its different from one you're
building.


Two types of Target's:
Dynamic - Has been parsed
Static

_______________________________________________________________________________
                         Macaroni Project File
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
local boost_headers = context:LoadProject("Macaroni", "Boost-Headers", "1.46.1")
local boost_regex = context:LoadProject("Macaroni", "Boost-regex", "1.46.1");
local lua = context:LoadProject("Macaroni, Lua", "5.1.4");
-- Each of these vars is a StaticLibrary.
-- boost_headers is just a list of Macaroni files to parse.
-- The next two are that plus a collection of C++ source as well as a DLL.
--   the DLL is only used for dynamic EXEs.
-- The Macaroni source in these is paresed before the next line is executed.


local lib = project:Library{name="lib",
                      dependencies={ boost_headers, boost_regex, lua },
                      sources= {FileSet("Source/main/**/*.cpp"),
                             -- Note: the regex will somehow skip Main.cpp.
                                FileSet("Source/main/**/*.mcpp"),
                                FileSet("Source/resources/**/*.cpp")}}
-- This creates a DynamicLibrary, which is a TargetCollection. The Macaroni
-- source is read right away. The C++ files instantly get added to the
-- TranslationUnit targets inside the library. But nothing is generated... yet.
-- DynamicLibrary also has a list of FileSets representing source.

local output = "GeneratedSource"

lib:Generate("LuaGlue", { luaImportCode =[[
	extern "C"
	{
		#include <lauxlib.h>
		#include <lualib.h>
	}
	]] });
-- This runs the LuaGlue generator. It adds extra stuff to the model.
-- Only the context and the lib target are passed in.


context:RunFileGenerator("HtmlView", output);
-- This runs the generator and outputs to output. Notice how its attached to
-- context- thats because there is no need for it to know which 'target'
-- created it, because it does not alter the model.

lib:Generate("Cpp", { output=output })
-- This generates CPP files. The lib is passed in, so each file is known to be
-- generated by it. More importantly though the output directory is passed
-- because new files are generated, and once the old plugin runs a legacy
-- adapter iterates this directory and adds a new "TranslationUnit" target to
-- the libraries list of targets, modifying the library.


context:RunFileGenerator("InterfaceMh", output);

local test1 = project:UnitTest{name="test1",
                       dependencies = { lib },
				 	   sources = {
				 	       "Source/test/Macaroni/Model/ContextTests.cpp"
				 	   }}
-- This just defines a target. Macaroni files are searched but here there
-- are none.
-- In theory a UnitTest could depend on a single unit as well as the whole
-- lib.
-- lib can be in sources of dependencies. In deps it makes sense, if its
-- in sources though it will try to link it in with the test.
-- This more important for exe below.

-- ** OR **
local test1 = lib:UnitTest{name="test1",
                           dependencies = { },
				 	       sources = {
				 	          "Source/test/Macaroni/Model/ContextTests.cpp"
				 	       }}
-- Library has a list of "requirements" which means anytime something adds
-- the library to a list of dependencies it must also add its list of
-- requirements. So if we do it this way the exe does not have to add
-- "dependsOn" below.


local exe = project:Exe{name="macaroni", sources={lib,
                   File("Source/main/mcpp/Main.cpp"),
                   File("Source/main/resource/Macaroni.rc")},
                dependsOn={test1}}
-- Sets a target annotation, for something we need to specify in Boost Build:
exe.Annotations["Macaroni.Build.Cpp.BoostBuild.Properties"] = [[
	 <target-os>windows:<linkflags>/LIBPATH:"]]]
            .. properties.boost.current["path"] .. [[/stage/lib";


-- Exe is a simple target type. It has a FileSet, and a reference to other
-- targets as source.
-- It also has a list of targets it "depends on" which means that tools which
-- generate the exe should try to compile or run these first, but they should
-- not be part of the EXE.



context:RunFileGenerator("JamGenerator", { targets = { exe } } );
-- Runs the Jam generator which creates the Boost.Build files.
-- Now whats interesting is it looks at exe, which has a small set of files
-- and a series of targets.
-- It figures out lib is a TargetCollection and grabs all translation units.
-- It then creates adds more source from the additional files in the fileset.
-- The Jamroot.jam file creates the library target as its own type.



_______________________________________________________________________________
                         Macaroni Project File SANS MUTABLE TARGETS
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
local boost_headers = context:LoadProject("Macaroni", "Boost-Headers", "1.46.1")
local boost_regex = context:LoadProject("Macaroni", "Boost-regex", "1.46.1");
local lua = context:LoadProject("Macaroni, Lua", "5.1.4");
-- Each of these vars is a StaticLibrary.
-- boost_headers is just a list of Macaroni files to parse.
-- The next two are that plus a collection of C++ source as well as a DLL.
--   the DLL is only used for dynamic EXEs.
-- The Macaroni source in these is paresed before the next line is executed.


local lib = project:Library{name="lib",
                      dependencies={ boost_headers, boost_regex, lua },
                      sources= {FileSet("Source/main/**/*.cpp"),
                                FileSet("Source/main/**/*.mcpp"),
                                FileSet("Source/resources/**/*.cpp")}}
-- This creates a DynamicLibrary, which is a TargetCollection. The Macaroni
-- source is read right away. The C++ files instantly get added to the
-- TranslationUnit targets inside the library. But nothing is generated... yet.

local output = "GeneratedSource"

local luaImportCode =[[
	extern "C"
	{
		#include <lauxlib.h>
		#include <lualib.h>
	}
	]]

luaLib = project:GenerateTarget("luaLib", "LuaGlue", lib,
                                { luaImportCode =luaImportCode });
-- Creates the luaLib target. Calls the LuaGlue generator with lib.

context:RunFileGenerator("HtmlView", output);
-- Runs a generator which does not alter the model.

cppLib = project:GenerateTarget("cppLib", "Cpp", lib, luaLib, {output=output})
-- Creates a new target "cppLib" with generated CPP files. Though the output
-- directory is passed because new files are generated, and once the old plugin
-- runs a legacy
-- adapter iterates this directory and adds a new "TranslationUnit" target to
-- the libraries list of targets, modifying the library. So cppLib is all these
-- units.

context:RunFileGenerator("InterfaceMh", output);

context:RunFileGenerator("JamGenerator", { libs = lib, luaLib, cppLib } );
-- Runs the Jam generator which creates the Boost.Build files.
-- Looks for translationUnits. Remeber that these are in lib too because of
-- its initial parse.


_______________________________________________________________________________
                         Macaroni Project File Plugins
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

-- I like this style the best:
lib:Generate("Cpp", {output=output})

-- But this style seems more flexible
local cpp = plugins:Get("Cpp")
local builder = BuildContext(lib, output)
cpp:Run("Generate", builder)

cpp:Run("Generate", lib, { output=output} )

-- The more I look at it actually I like this the best:
local bjam = plugins:Get("bjam")
local cpp = plugins:Get("Cpp")

local buildContext = BuildContext("target")
cpp:Run("Generate", lib, buildContext, {})


bjam:Run("Generate", lib, buildContext, {

})



_______________________________________________________________________________
                         Macaroni Project Tasks
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Tasks are methods with dependencies.
The interface in C++ is something like:

class Task {
    virtual list<int> dependsOn() const = 0;
    virtual int uuid() const = 0;
    virtual void operator()() = 0;
}

These are created and thrown into a bit of code that sorts them out before
running them.

_______________________________________________________________________________
                            ANNOTATIONS
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Macaroni.Project - denotes the Node as belonging to the given project.
In any active build context, only one Version of a project is allowed.
So the version does not need to be specified.

Macaroni.Project.Target - A string. The default is "core". Or maybe "default."



Macaroni.Environment - A decorator for a Context which gives it neat abilities.
Eventually all work happens here.
At start up, it reads the file project.lua in the root directory. It then goes
into a Lua REPL if interactive mode is specified.



