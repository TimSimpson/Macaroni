/**
 * Copyright 2011 Tim Simpson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
~import boost::format;
~import BOOST_FOREACH;
~import Macaroni::Model::Project::Files;
~import Macaroni::Model::Project::FilesPtr;
~import Macaroni::IO::FileSet;
~import Macaroni::IO::FileSetPtr;
~import Macaroni::Environment::Values::Macaroni_IO_FileSet;
~import Macaroni::Model::Element;
~import Macaroni::Exception;
~import boost::intrusive_ptr;
~import Macaroni::Model::Project::LibraryTarget;
~import Macaroni::Model::Project::LibraryTargetPtr;
~import Macaroni::Lua::LuaClass;
~import Macaroni::Environment::LuaEnvironment;
~import Macaroni::Lua::LuaFunction;
~import Macaroni::Lua::LuaGlueCode;
~import Macaroni::Lua::LuaIncludes;
~import Macaroni::Lua::LuaOperator;
~import Macaroni::Lua::LuaProperty;
~import  Macaroni::Environment::Values::Macaroni_Model_Project_Files;
~import Macaroni::Model::NodePtr;
~import Macaroni::Model::Project::Project;
~import Macaroni::Model::Project::ProjectPtr;
~import Macaroni::Model::Reason;
~import std::string;
~import Macaroni::Environment::Values::String;
~import Macaroni::StringException;
~import Macaroni::Environment::Values::Table;
~import Macaroni::Environment::Values::TablePtr;
~import Macaroni::Model::Project::Target;
~import Macaroni::Model::Project::TargetPtr;
~import Macaroni::Cpp::UseLightDef;
~import Macaroni::Model::Project::Utils;
~import std::vector;


class Macaroni::Model::Project::ProjectVersion {};

typedef intrusive_ptr<Macaroni::Model::Project::ProjectVersion ~l>
	Macaroni::Model::Project::ProjectVersionPtr
		@LuaClass [ SameAsNode = Macaroni::Model::Project::ProjectVersion ]
		@UseLightDef true;

class Macaroni::Model::Project::ProjectVersion
	@LuaClass [
		ReferenceType = Macaroni::Model::Project::ProjectVersionPtr
	]
	@LuaIncludes ={
		#include <Macaroni/Environment/Values/Any.h>
		#include <Macaroni/Environment/Values/AnyPtr.h>
		#include <Macaroni/Model/Project/Files.h>
		#include <Macaroni/Environment/Values/Table.h>
	}
{
	friend Macaroni::Model::Project::Project;

	private Macaroni::Model::Project::Project * const project;
	private std::vector<Target *> targets;
	private const string version;

	private ProjectVersion(Project * project, const string & version)
	:   project(project),
	    version(version)
	{
	}

	private ~ProjectVersion()
	{
		BOOST_FOREACH(Macaroni::Model::Project::Target * target,
		              targets)
		{
			delete target;
		}
	}

	public bool operator==(const ProjectVersion & other) const {
		return (*project == *other.project
			    && version == other.version);
	}

	private void addTarget(Target * target) {
		BOOST_FOREACH(Macaroni::Model::Project::Target * t, targets) {
			if (t->GetName() == target->GetName()) {
				throw Macaroni::StringException("Target already added.");
			}
		}
		targets.push_back(target);
	}

	/** Returns a version of this ID which can be used as a C identifier.
	 * The point isn't to make a pretty name but just one that maps uniquely.
	 */
	public string GetCId() const
		@LuaFunction "GetCId"
	{
		return str(format("%s___%s") % project->GetCId() 
			                         % Utils::CreateCId(version));
	}

	public Macaroni::Model::Project::ProjectPtr GetProject() const
		@LuaProperty "Project"
	{
		Macaroni::Model::Project::ProjectPtr ptr(project);
		return ptr;
	}

	public TargetPtr GetTarget(const std::string & name)
		@LuaFunction "GetTarget"
	{
		BOOST_FOREACH(Macaroni::Model::Project::Target * target, targets)
		{
			if (target->GetName() == name)
			{
				TargetPtr ptr(target);
				return ptr;
			}
		}
		TargetPtr ptr;
		return ptr;
	}

	public inline const string & GetVersion() const
		@LuaProperty "Version"
	{
		return version;
	}	

	public ~global ~friend void intrusive_ptr_add_ref(
		Macaroni::Model::Project::ProjectVersion * const p)
	{
		intrusive_ptr_add_ref((Macaroni::Model::Project::Project *) p->project);
	}

	public ~global ~friend void intrusive_ptr_release(
		Macaroni::Model::Project::ProjectVersion * const p)
	{
		intrusive_ptr_release((Macaroni::Model::Project::Project *) p->project);
	}

	public LibraryTargetPtr Library(Table & table)
		@LuaFunction "Library"
		@LuaGlueCode ={
			ProjectVersionPtr & instance =
				ProjectVersionLuaMetaData::GetInstance(L, 1);
			Table table;
			boost::optional<string> key("Library argument 2");
			LuaEnvironment::SerializeTable(table, L, 2, key);

			LibraryTargetPtr lib = instance->Library(table);
			
			TargetLuaMetaData::PutInstanceOnStack(L, lib);
			return 1;
		}
	{
		string name = table.Get<String>("name");
		FilesPtr sources = table.Get<Macaroni_Model_Project_Files>("sources");
		//Table & source = 
		//	*(table.GetAsAnyType<Table>("sources"));
		//FilesPtr sources = Files::New(source);

		vector<TargetPtr> dependencies;
///*
//		FilesPtr sources(new Files());
//		vector<boost::variant<int, string> > sourceKeys;
//		table.CopyKeyList(sourceKeys);
//
//		struct FillArray{
//			FileListPtr list;
//			operator()(FileSetPtr & fileSet)
//			{
//				list->push_back(fileSet);
//			}
//		};
//
//		BOOST_FOREACH(boost::variant<int, string> & sourceKey, sourceKeys)
//		{
//			FileListPtr newList(new FileList());
//			(*sources)["Macaroni"] = newList;
//			FillArray fa;
//			fa.list = newList;
//			table.ToVector<Macaroni_IO_FileSet, FillArray>(fa);
//		}*/
		/*
		vector<FileSetPtr> sources;
		if (table.Has("sources")) 
		{
			table.GetVector<Macaroni_IO_FileSet>(
				sources, "sources");
		}
		vector<FileSetPtr> headers;
		if (table.Has("headers")) 
		{
			table.GetVector<Macaroni_IO_FileSet>(
				sources, "sources");
		}*/
		LibraryTargetPtr lib = LibraryTarget::Create(
			this, name, dependencies, sources);
		addTarget(lib.get());
		return lib;
	}
	
	public LibraryTargetPtr Library(
		string name,
		const vector<TargetPtr> & dependencies,
		FilesPtr sources
	)
	{
		LibraryTargetPtr lib = LibraryTarget::Create(this, name, dependencies, sources);
		addTarget(lib.get());
		return lib;
	}

	public TargetPtr Target(const std::string & name)
		@LuaFunction "Target"
	{
		using Macaroni::Model::Project::Target;
		TargetPtr target(new Target(this, name));
		addTarget(target.get());
		return target;
	}

	public string ToString() const
		@LuaOperator "__tostring"
	{
		return str(format("%s, Version=\"%s\"")
		           % project->ToString() % version);
	}
};

//TODO: There is a bug that keeps Macaroni from working if the namespace
// is declared above like usual.
namespace Macaroni::Model::Project {}
