/**
 * Copyright 2011 Tim Simpson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
~import Macaroni::Model::Project::Artifact;
~import Macaroni::Model::Project::ArtifactPtr;
~import Macaroni::Model::Element;
~import Macaroni::Exception;
~import boost::format;
~import BOOST_FOREACH;
~import Macaroni::Model::Project::Files;
~import Macaroni::Model::Project::FilesPtr;
~import Macaroni::IO::FileSet;
~import Macaroni::IO::FileSetPtr;
~import Macaroni::Model::Project::Group;
~import boost::intrusive_ptr;
~import Macaroni::Model::Project::LibraryTarget;
~import Macaroni::Model::Project::LibraryTargetPtr;
~import Macaroni::Lua::LuaClass;
~import Macaroni::Environment::LuaEnvironment;
~import Macaroni::Lua::LuaFunction;
~import Macaroni::Lua::LuaGlueCode;
~import Macaroni::Lua::LuaIncludes;
~import Macaroni::Lua::LuaOperator;
~import Macaroni::Lua::LuaProperty;
~import Macaroni::Environment::Values::Macaroni_IO_FileSet;
~import Macaroni::Environment::Values::Macaroni_IO_PathList;
~import Macaroni::Environment::Values::Macaroni_Model_Project_Files;
~import Macaroni::Environment::Values::Macaroni_Model_Project_Target;
~import Macaroni::Model::NodePtr;
~import Macaroni::IO::PathList;
~import Macaroni::IO::PathListPtr;
~import Macaroni::Model::Project::Project;
~import Macaroni::Model::Project::ProjectPtr;
~import Macaroni::Model::Reason;
~import std::string;
~import Macaroni::Environment::Values::String;
~import Macaroni::StringException;
~import Macaroni::Environment::Values::Table;
~import Macaroni::Environment::Values::TablePtr;
~import Macaroni::Model::Project::Target;
~import Macaroni::Model::Project::TargetPtr;
~import Macaroni::Cpp::UseLightDef;
~import Macaroni::Model::Project::Utils;
~import std::vector;


class Macaroni::Model::Project::ProjectVersionId {
	public string Group;
	public string Name;
	public string Version;

	public ProjectVersionId(string group, string name, string version)
	:	Group(group), Name(name), Version(version)
	{
	}	

	public string ToString() const
	{
		return str(format("%s / %s / %s") % Group % Name % Version);
	}
};

class Macaroni::Model::Project::ProjectVersion {};

typedef intrusive_ptr<Macaroni::Model::Project::ProjectVersion ~l>
	Macaroni::Model::Project::ProjectVersionPtr
		@LuaClass [ SameAsNode = Macaroni::Model::Project::ProjectVersion ]
		@UseLightDef true;

class Macaroni::Model::Project::ProjectVersion
	@LuaClass [
		ReferenceType = Macaroni::Model::Project::ProjectVersionPtr
	]
	@LuaIncludes ={
		#include <Macaroni/Environment/Values/Any.h>
		#include <Macaroni/Environment/Values/AnyPtr.h>
		#include <Macaroni/Model/Project/Files.h>
		#include <Macaroni/Environment/Values/Table.h>
	}
{
	~import Macaroni::Model::Project::ProjectVersionId;
	friend Macaroni::Model::Project::Project;

	private Macaroni::Model::Project::Project * const project;
	private std::vector<Target *> targets;
	private const string version;

	private ProjectVersion(Project * project, const string & version)
	:   project(project),
	    version(version)
	{
	}

	private ~ProjectVersion()
	{
		BOOST_FOREACH(Macaroni::Model::Project::Target * target,
		              targets)
		{
			delete target;
		}
	}

	public bool operator==(const ProjectVersion & other) const {
		return (*project == *other.project
			    && version == other.version);
	}	

	public void AddTarget(Target * target) {
		BOOST_FOREACH(Macaroni::Model::Project::Target * t, targets) {
			if (t->GetName() == target->GetName()) {
				throw Macaroni::StringException("Target already added.");
			}
		}
		targets.push_back(target);
	}

	/** Returns a version of this ID which can be used as a C identifier.
	 * The point isn't to make a pretty name but just one that maps uniquely.
	 */
	public string GetCId() const
		@LuaFunction "GetCId"
	{
		return str(format("%s___%s") % project->GetCId() 
			                         % Utils::CreateCId(version));
	}

	public Macaroni::Model::Project::ProjectPtr GetProject() const
		@LuaProperty "Project"
	{
		Macaroni::Model::Project::ProjectPtr ptr(project);
		return ptr;
	}

	public TargetPtr GetTarget(const std::string & name)
		@LuaFunction "GetTarget"
	{
		BOOST_FOREACH(Macaroni::Model::Project::Target * target, targets)
		{
			if (target->GetName() == name)
			{
				TargetPtr ptr(target);
				return ptr;
			}
		}
		TargetPtr ptr;
		return ptr;
	}

	public inline const string & GetVersion() const
		@LuaProperty "Version"
	{
		return version;
	}	

	public ~global ~friend void intrusive_ptr_add_ref(
		Macaroni::Model::Project::ProjectVersion * const p)
	{
		intrusive_ptr_add_ref((Macaroni::Model::Project::Project *) p->project);
	}

	public ~global ~friend void intrusive_ptr_release(
		Macaroni::Model::Project::ProjectVersion * const p)
	{
		intrusive_ptr_release((Macaroni::Model::Project::Project *) p->project);
	}

	public LibraryTargetPtr Library(Table & table)
		@LuaFunction "Library"
		@LuaGlueCode ={
			ProjectVersionPtr & instance =
				ProjectVersionLuaMetaData::GetInstance(L, 1);
			Table table;
			boost::optional<string> key("Library argument 2");
			LuaEnvironment::SerializeTable(table, L, 2, key);

			LibraryTargetPtr lib = instance->Library(table);
			
			TargetLuaMetaData::PutInstanceOnStack(L, lib);
			return 1;
		}
	{
		string name = table.Get<String>("name");
		//FilesPtr sources = table.Get<Macaroni_Model_Project_Files>("sources");
		PathListPtr headers;
		if (table.Has("headers"))
		{
			headers = table.Get<Macaroni_IO_PathList>("headers");
		}
		else
		{
			headers.reset(new PathList());
		}
		PathListPtr sources = table.Get<Macaroni_IO_PathList>("sources");
		
		
		vector<TargetPtr> dependencies;

		if (table.Has("dependencies"))
		{
			struct Func
			{
				vector<TargetPtr> & dependencies;
				
				Func(vector<TargetPtr> & dependencies)
				: dependencies(dependencies) 
				{
				}

				void operator ()(TargetPtr target) 
				{
					dependencies.push_back(target);
				}
			};
			Func f(dependencies);
			table.ToVector<Macaroni_Model_Project_Target, Func>(f);
		}
		
		LibraryTargetPtr lib = LibraryTarget::Create(
			this, name, dependencies, headers, sources);
		//addTarget(lib.get());
		return lib;
	}
	
	///*public LibraryTargetPtr Library(
	//	string name,
	//	const vector<TargetPtr> & dependencies,
	//	FilesPtr sources
	//)
	//{
	//	LibraryTargetPtr lib = LibraryTarget::Create(this, name, dependencies, sources);
	//	addTarget(lib.get());
	//	return lib;
	//}*/

	public TargetPtr Target(const std::string & name)
		@LuaFunction "Target"
	{
		using Macaroni::Model::Project::Target;
		TargetPtr target = GetTarget(name);
		if (!target)
		{
			target.reset(new Target(this, name));
			//addTarget(target.get());
		}
		return target;
	}

	ProjectVersionId ToId() const
	{
		return ProjectVersionId(this->GetProject()->GetGroup()->GetName(),
			this->GetProject()->GetName(), this->GetVersion());
	}

	public string ToString() const
		@LuaOperator "__tostring"
	{
		return str(format("%s, Version=\"%s\"")
		           % project->ToString() % version);
	}
};

//TODO: There is a bug that keeps Macaroni from working if the namespace
// is declared above like usual.
namespace Macaroni::Model::Project {}
