/**
 * Copyright 2011 Tim Simpson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
~import boost::intrusive_ptr;
~import boost::lexical_cast;
~import Macaroni::Lua::LuaClass;
~import Macaroni::Lua::LuaIncludes;
~import Macaroni::Lua::LuaIndexExtraCode;
~import Macaroni::Lua::LuaFunction;
~import Macaroni::Lua::LuaOperator;
~import Macaroni::Lua::LuaProperty;
~import Macaroni::Model::Node;
~import std::ostream;
~import std::pair;
~import std::string;
~import std::stringstream;
~import Macaroni::Model::TypeArgumentList;
~import Macaroni::Model::TypeArgumentListPtr;
~import Macaroni::Model::TypeModifiers;
~import std::unique_ptr;
~import std::vector;


~namespace Macaroni::Model;


class Type {};
class TypeList {};

typedef boost::intrusive_ptr<Type ~l> TypePtr
	@LuaClass
	[
		SameAsNode = Type
	]
;



//TODO: This HAS to start living in the Context.  It is a memory leak... can't
// believe I didn't notice it at the time.
/** Represents a Type.  A type does not exist in the Node system, but does
 * point to a Node.
 * This may also store a list of TypeArguments, where each element points to
 * a Node that relates to the type node, with additional nodes offering
 * argument data. */
class Type
	@LuaClass
	[
		ReferenceType = Macaroni::Model::TypePtr
	]
	@LuaIncludes = {
		// A bug is necessitating
		#include <Macaroni/Model/TypeListLuaMetaData.h>
	}
{
	private vector<unique_ptr<TypeArgumentList>> arguments;
	private Context * context;
	private TypeModifiers modifiers;
	private Node * node;

	friend Context;
	friend TypeArgumentList;

	protected explicit Type(Context * context)
	:	arguments(),
		context(context),
		modifiers(),
		node(nullptr)
	{
	}

	protected explicit Type(Node * type, TypeModifiers modifiers)
	:	arguments(),
		context(type->context),
		modifiers(modifiers),
		node(type)
	{
	}

	public ~Type()
	{
	}

	public bool operator== (const Type & other) const
	{
		if (this->node == other.node
			&& this->modifiers == other.modifiers
			&& this->arguments.size() == other.arguments.size())
		{
			for (unsigned int i = 0; i < this->arguments.size(); ++ i)
			{
				if (*(this->arguments[i]) != *(other.arguments[i]))
				{
					return false;
				}
			}
			return true;
		}
		return false;
	}

	public bool operator!= (const Type & other) const
	{
		return ! this->operator==(other);
	}

	public ~global ~friend ostream & operator<<(ostream & out,
    	                                        const Type & type)
    {
    	out << type.node ? type.node->GetFullName() : "<null>";
		if (type.arguments.size() > 0)
		{
			for (const auto & arg : type.arguments)
			{
				out << *(arg);
			}
		}
		out << type.modifiers;
    	return out;
    }

	public TypeArgumentListPtr AddArgument(int index)
	{
		arguments.emplace_back(new TypeArgumentList(this, index));
		return TypeArgumentListPtr{arguments.back().get()};
	}

	public inline const vector<unique_ptr<TypeArgumentList>> &
		GetArguments() const
	{
		return arguments;
	}

	public inline const TypeList GetArgumentsLua() const
		@LuaProperty "Arguments"
	{
		TypeList tl{*this};
		return tl;
	}

	// For the stupidly named old property.
	public inline const TypeList GetArgumentsLua2() const
		@LuaProperty "TypeArguments"
	{
		TypeList tl{*this};
		return tl;
	}

	public inline NodePtr GetNode() const
		@LuaProperty "Node"
	{
		return node;
	}

	public ~global ~friend void intrusive_ptr_add_ref(const Type * p)
	{
		intrusive_ptr_add_ref(p->context);
	}

	public ~global ~friend void intrusive_ptr_release(const Type * p)
	{
		intrusive_ptr_release(p->context);
	}

	public TypeModifiers & GetModifiers()
	{
		return modifiers;
	}

	public const TypeModifiers & GetModifiers() const
		@LuaProperty "Modifiers"
	{
		return modifiers;
	}

	public inline void SetModifiers(const TypeModifiers & modifiers)
	{
		this->modifiers = modifiers;
	}

	public inline void SetNode(NodePtr node)
		@LuaProperty "Node"
	{
		this->node = node.get();
	}

	public string ToString() const
		@LuaOperator "__tostring"
	{
		stringstream ss;
		ss << *this;
		return ss.str();
	}

};


class TypeList

	// This class exists primarily to wrap the list in Lua glue.

	@LuaClass
	[
		ReferenceType = Macaroni::Model::TypeList
	]
	@LuaIndexExtraCode = {
		const string index_0(luaL_checkstring(L, 2));
		const auto index_1 = lexical_cast<int>(index_0);
		const vector<unique_ptr<TypeArgumentList>> & list
			= instance.type_.GetArguments();
		if (0 > index_1 || list.size() - 1 < index_1)
		{
			lua_pushnil(L);
		}
		else
		{
			TypeArgumentListPtr talp(list[index_1].get());
			TypeArgumentListLuaMetaData::PutInstanceOnStack(L, talp);
		}
		return 1;
	}
{
	~import Macaroni::Model::Type;

	public const Type & type_;

	public explicit TypeList(const Type & type)
	:	type_(type)
	{
		intrusive_ptr_add_ref(&type_);
	}

	public ~TypeList()
	{
		intrusive_ptr_release(&type_);
	}
}
