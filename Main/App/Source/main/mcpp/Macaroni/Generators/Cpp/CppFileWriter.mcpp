~import Macaroni::Model::Cpp::Access;
~import Macaroni::Model::Cpp::AccessPtr;
~import Macaroni::Model::Cpp::Class;
~import Macaroni::Model::Cpp::ClassParent;
~import Macaroni::Model::Cpp::ClassParentPtr;
~import Macaroni::Model::Cpp::ClassParentList;
~import Macaroni::Model::Cpp::ClassParentListPtr;
~import Macaroni::Model::Cpp::ConstructorOverload;
~import Macaroni::Model::Cpp::ConstructorOverloadPtr;
~import Macaroni::Model::Context;
~import Macaroni::Model::Element;
~import Macaroni::Model::ElementPtr;
~import boost::format;
~import Macaroni::Model::Cpp::FunctionOverload;
~import Macaroni::Model::Cpp::FunctionOverloadPtr;
~import Macaroni::Model::Node;
~import Macaroni::Model::NodePtr;
~import Macaroni::IO::GeneratedFileWriter;
~import Macaroni::IO::GeneratedFileWriterPtr;
~import boost::optional;
~import std::string;
~import Macaroni::Model::Cpp::TemplateTypename;
~import Macaroni::Model::Cpp::TemplateTypenamePtr;
~import Macaroni::Model::Type;
~import Macaroni::Model::TypePtr;
~import Macaroni::Model::Cpp::Variable;
~import Macaroni::Model::Cpp::VariablePtr;
~import std::set;
~import Macaroni::Model::Cpp::Typedef;

~namespace Macaroni::Generators::Cpp;


class CppFileWriter
// Decorates the normal text writer to handle writing C++ code to both header
// and implementation files.
{
    NodePtr currentNamespace;
    const int maxWidth;
    set<string> includedFiles;
    optional<string> libDecl;
    int lineNumber;
    NodePtr rootNs;
    int tabs;
    GeneratedFileWriterPtr writer;

    public CppFileWriter(optional<string> libDecl,
                         NodePtr currentNamespace,
                         GeneratedFileWriterPtr writer)
    :   currentNamespace(currentNamespace),
        libDecl(libDecl),
        lineNumber(1),
        maxWidth(80),
        rootNs(currentNamespace->GetContext()->GetRoot()),
        tabs(0),
        writer(writer)
    {
    }

    public void Access(AccessPtr access)
    {
        if (access)
        {
            write(access->CppKeyword());
        }
    }

    public void BeginArgumentList()
    {
        write("(");
    }

    public void ClassMemberAccess(AccessPtr access)
    {
        if (access)
        {
            write(access->CppKeyword());
            write(": ");
        }
    }

    public void ClassName(Class & e)
    {
        write(e.GetNode()->GetName());
    }

    public void ClassOrStructKeyword(Class & e)
    {
        write(e.IsStruct() ? "struct " : "class ");
    }

    public void ClassParentList(Class & e)
    {
        ClassParentListPtr parents = e.GetParents();
        bool seenOne = false;
        MACARONI_ASSERT(parents, "Parents is null.");
        for (ClassParent & parent : *parents)
        {
            if (!seenOne)
            {
                writeLine("");
                write(":   ");
                seenOne = true;
            }
            else
            {
                writeLine("");
                write(",   ");
            }
            this->Access(parent.GetAccess());
            write(" ");
            if (parent.IsVirtual())
            {
                write("virtual ");
            }
            Type(parent.GetParent(), true);
        }
    }

    public void CloseBrace()
    {
        tabs -= 1;
        writeLine();
        // {  Appeasing Macaroni
        writeLine("}");
    }

    public void CloseBraceForClass()
    {
        tabs -= 1;
        writeLine();
        // {  Appeasing Macaroni
        writeLine("};");
    }

    public void Comment(const std::string & text)
    {
        writeLine("// ", text);
    }

    public void ConstructorInitializerList(ConstructorOverload & co)
    {
        bool seenOne = false;
        for (signed int i = 0; i < co.GetAssignmentCount(); ++ i)
        {
            auto va = co.GetAssignment(i);
            if (!seenOne)
            {
                write(": ");
                seenOne = true;
            }
            else
            {
                writeLine(", ");
            }
            write(va.GetVariable()->GetName());
            write("(");
            write(va.GetExpression());
            write(")");
        }
        if (seenOne)
        {
            writeLine();
        }
    }

    public void DestructorName(Class & c)
    {
        write("~");
        write(c.GetNodeRef().GetName());
    }

    public void EndArgumentList()
    {
        write(")");
    }

    public void EnterNamespace(NodePtr ns)
    {
        auto pos = currentNamespace->FindSharedRoot(ns);
        //writeLine("MARIO, the common Index is ", pos.commonIndex);
        int index;
        for (index = pos.a.size() - 1;
             index > pos.commonIndex;
             -- index)
        {   // {  MACARONI BUG
            write("} ");
        }
        writeLine();
        //writeLine("MARIO pos.a.size() ", pos.a.size());
        //writeLine("MARIO pos.b.size() ", pos.b.size());

        for (++ index;
             index <= pos.b.size() - 1;
             ++ index)
        {
            //write("namespace ", index, " MARIO ", pos.b[index]->GetName(), );
            write("namespace ", pos.b[index]->GetName(), " { ");
            // MACARONI BUG }
        }
        writeLine();
        currentNamespace = ns;
    }

    public void EndStatement()
    {
        writeLine(";");
    }

    public void ExitNamespaces()
    {
        for (int i = currentNamespace->GetDepth(); i > 0; -- i)
        {   // {  MACARONI BUG
            write(" } ");
        }
    }

    public void ExplicitKeyword()
    {
        write("explicit ");
    }

    public void FriendClassName(Class & c)
    {
        write("class ");
        NodePtr parent = c.GetNodeRef().GetParent();
        if (parent != nullptr &&
                (*parent == *currentNamespace
                 || *parent == c.GetNodeRef())
           )
        {
            write(c.GetNodeRef().GetName());
        }
        else
        {
            write("::");
            write(c.GetNodeRef().GetFullName());
        }
    }

    public void FriendFunctionOverloadName(FunctionOverload & fo)
    {
        functionOverloadDefinition(fo, true, true, false);
    }

    public void FriendKeyword()
    {
        write("friend ");
    }

    public void FunctionArgument(Variable & v, bool withInitializer)
    {
        Type(v.GetType(), !withInitializer);
        Space();
        WriteNodeName(v.GetNode());
        auto init = v.GetInitializer();
        if (withInitializer && init.length() > 0)
        {
            write("=", init);
        }
    }

    public void FunctionArgumentList(FunctionOverload & fo,
                                     bool writeDefaultArgs)
    {
        BeginArgumentList();
        auto args = fo.GetArguments();
        bool seenOne = false;
        for (auto arg : *args)
        {
            if (seenOne)
            {
                FunctionArgumentSeperator();
            }
            Variable * v = arg->GetElementPtr<Variable>();
            MACARONI_ASSERT(v, "null var for argument?");
            FunctionArgument(*v, writeDefaultArgs);
            seenOne = true;
        }
        EndArgumentList();
    }

    public void FunctionArgumentSeperator()
    {
        write(", ");
    }

    public void FunctionCodeBlock(FunctionOverload & fo)
    {
        MACARONI_ASSERT(fo.HasCodeBlock(),
                        "Missing function overload code block.");
        auto cb = fo.GetCodeBlock();
        auto srcPtr = fo.GetCodeSource();
        MACARONI_ASSERT(srcPtr, "Source pointer is nil?");
        auto redirect = fo.CodeBlockShouldAddRedirect();
        OpenBrace();
        writeLine();
        if (redirect)
        {
            write("#line ");
            write(srcPtr->GetLine());
            write(" \"");
            write(srcPtr->GetFileName()->GetName());
            writeLine("\"");
        }
        writeLine(cb);

        write("#line ");
        write(lineNumber);
        write(" \"");
        write(writer->GetFilePath());
        writeLine("\"");

        CloseBrace();
    }

    public void FunctionExceptionSpecifier(FunctionOverload & fo)
    {
        auto es = fo.GetExceptionSpecifier();
        if (es)
        {
            write(" ");
            write(es.get().GetCodeText());
        }
    }

    public void FunctionHeaderBody(FunctionOverload & fo)
    {
        functionHeaderBody(fo);
    }

    public void FunctionHeaderBody(ConstructorOverload & fo)
    {
        functionHeaderBody(fo);
    }

    template<typename FunctionOverloadType>
    ~hidden void functionHeaderBody(FunctionOverloadType & fo)
    {
        if (fo.IsPureVirtual())
        {
            writeLine(" = 0;");
        }
        else if (fo.UsesDefault())
        {
            writeLine(" = default;");
        }
        else if (fo.IsDeleted())
        {
            writeLine(" = delete;");
        }
        else if (fo.IsInline())
        {
            functionHeaderBodyInlineCodeBlock(fo);
        }
        else
        {
            writeLine(";");
        }
    }

    ~hidden void functionHeaderBodyInlineCodeBlock(ConstructorOverload & fo)
    {
        ConstructorInitializerList(fo);
        FunctionCodeBlock(fo);
    }

    ~hidden void functionHeaderBodyInlineCodeBlock(FunctionOverload & fo)
    {
        FunctionCodeBlock(fo);
    }

    public void FunctionOverloadDefinition(FunctionOverload & fo)
    {}

    ~hidden void functionOverloadDefinition(
        FunctionOverload & fo, bool calledInsideClassDef,
        bool calledForFriendDef, bool writeDefaultArgs)
    {
        auto access = fo.GetAccess();
        if (access->VisibleInLibrary() && this->libDecl && !calledInsideClassDef
            && !fo.GetTemplateParameterList())
        {
            LibDecl();
            writeLine();
        }
        if (fo.IsStatic())
        {
            StaticKeyword();
        }
        if (fo.UsesInlineKeyword())
        {
            InlineKeyword();
        }
        Type(fo.GetReturnType(), true);
        if (!calledForFriendDef)
        {
            write(" ");
            write(fo.GetNodeRef().GetName());
        }
        else
        {
            write(" (::");
            write(fo.GetNodeRef().GetFullName());
            write(") ");
        }
        FunctionArgumentList(fo, writeDefaultArgs);
        write(")");
        if (fo.IsConst())
        {
            write(" const");
        }
        FunctionExceptionSpecifier(fo);
        if (fo.UsesOverrideKeyword())
        {
            write(" override");
        }
        auto trt = fo.GetTrailingReturnType();
        if (trt)
        {
            write(" -> ");
            write(trt.get());
        }
    }

    ~hidden void includeFile(string & file)
    {
        if (includedFiles.find(file) == includedFiles.end())
        {
            EnterNamespace(rootNs);
            write("#include ", file);
            writeLine();
            includedFiles.insert(file);
        }
    }

    public void IncludeFile(Element & element)
    {
        NodePtr node = element.GetNode();
        // If the hfile is set, use it.
        auto fileNamePtr = node->GetHFilePath();
        if (fileNamePtr)
        {
            string file = fileNamePtr->GetName();
            includeFile(file);
            return;
        }
        else
        {
            // If the node was adopted, use that.
            NodePtr adoptedHome = node->GetAdoptedHome();
            if (adoptedHome)
            {
                MACARONI_ASSERT(adoptedHome->GetElementPtr(), "Element not set.");
                IncludeFile(*(adoptedHome->GetElementPtr()));
                return;
            }
            else
            {
                // See if this is nested under a class, if so, use that.
                NodePtr parent = node->GetParent();
                if (parent)
                {
                    if (parent->GetElementPtr<Class>())
                    {
                        IncludeFile(*(parent->GetElementPtr()));
                        return;
                    }
                    NodePtr parentParent = parent->GetParent();
                    if (parentParent && parentParent->GetElementPtr<Class>())
                    {
                        IncludeFile(*(parentParent->GetElementPtr()));
                        return;
                    }
                }
            }
            // Finally if its a class or typedef, make up an hfile.
            if (node->GetElementPtr<Class>()
                || node->GetElementPtr<Typedef>())
            {
                includeFile(str(boost::format("%s.h")
                                % node->GetPrettyFullName("/")));
                return;
            }
        }
    }

    public void InlineKeyword()
    {
        write("inline ");
    }

    public void LibDecl()
    {
        if (libDecl)
        {
            write(libDecl.get());
            write(" ");
        }
    }

    public void OpenBrace()
    {
        writeLine();
        tabs += 1;
        writeLine("{");
        // Appeasing macaroni...  }
    }

    public void Space()
    {
        write(' ');
    }

    public void StaticKeyword()
    {
        write("static ");
    }

    public void TemplateParameterList(Class & e)
    {
        templateParameterList(e.GetTemplateParameterList());
    }

    ~hidden void templateParameterList(NodePtr & tpl)
    {
        if (!tpl)
        {
            return;
        }
        write("template<");
        bool seenOne = false;
        for (unsigned int i = 0; i < tpl->GetChildCount(); ++ i)
        {
            auto var = tpl->GetChild(i)->GetElementPtr<TemplateTypename>();
            if (var)
            {
                if (seenOne)
                {
                    this->write(", ");
                }
                seenOne = true;
                write("typename ");
                if (var->IsParameterPack())
                {
                    write("... ");
                }
                write(var->GetNodeRef().GetName());
            }
        }
        /*tpl->IterateNodes([&seenOne, this] (TemplateTypename & tn) {
            if (seenOne)
            {
                this->write(", ");
            }
            seenOne = true;
            write("typename ");
            if (tn.IsParameterPack())
            {
                write("... ");
            }
            write(tn.GetNodeRef().GetName());
        });*/
        writeLine(">");
    }

    public void Type(TypePtr type, bool attemptShortName)
    {
        write(type->CreateCodeDefinition(currentNamespace));
    }

    public void TypedefKeyword()
    {
        write("typedef ");
    }

    public void VirtualKeyword()
    {
        write("virtual ");
    }

    template<typename... Parameters>
    private void write(const Parameters & ... args)
    {
        writer->Write(args...);
    }

    public void WriteClassKeyword()
    {
        writer->Write("class ");
    }

    public void WriteFullNodeName(NodePtr node)
    {
        writer->Write(node->GetFullName());
    }

    public void WriteNodeName(NodePtr node)
    {
        writer->Write(node->GetName());
    }

    public void WriteSyntax(const std::string & text)
    {
        writer->Write(text);
    }

    template<typename... Parameters>
    private void writeLine(const Parameters & ... args)
    {

        writer->WriteLine(args...);
        ++ lineNumber;
        writer->Write(std::string(tabs * 4, ' '));
    }

};
