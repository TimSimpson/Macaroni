~import Macaroni::Core::BaseVisitor;
~import Macaroni::Generators::Cpp::CodeGraph;
~import Macaroni::Generators::Cpp::CodeText;
~import Macaroni::Generators::Cpp::CodeTextProducer;
~import Macaroni::Generators::Cpp::CodeTextSorter;
~import Macaroni::Generators::Cpp::CodeType;
~import Macaroni::Generators::Cpp::CppFileWriter;
~import Macaroni::Model::Cpp::Class;
~import Macaroni::Model::Context;
~import std::cout;
~import Macaroni::Model::Element;
~import Macaroni::Model::ElementPtr;
~import Macaroni::Model::Cpp::Function;
~import Macaroni::Model::Cpp::FunctionOverload;
~import Macaroni::IO::GeneratedFileWriter;
~import Macaroni::IO::GeneratedFileWriterPtr;
~import Macaroni::Generators::Cpp::Library::LibraryConfigGenerator;
~import Macaroni::Model::Project::LibraryTarget;
~import Macaroni::Model::Project::LibraryTargetPtr;
~import Macaroni::Lua::LuaClass;
~import Macaroni::Lua::LuaFunction;
~import Macaroni::Lua::LuaOperator;
~import Macaroni::Model::Node;
~import Macaroni::Model::NodePtr;
~import Macaroni::IO::Path;
~import Macaroni::IO::PathPtr;
~import Macaroni::Exception::SimpleException;
~import boost::shared_ptr;
~import std::string;
~import Macaroni::Model::Project::Target;
~import Macaroni::Model::Project::TargetPtr;
~import Macaroni::Model::Type;
~import Macaroni::Model::TypePtr;
~import Macaroni::Model::Project::UnitTarget;
~import Macaroni::Core::Variable;
~import std::vector;
~import Macaroni::Model::Cpp::Variable;
~import Macaroni::Core::Visitor;



~namespace Macaroni::Generators::Cpp::Unit;


class UnitFileGenerator {};

typedef shared_ptr<UnitFileGenerator> UnitFileGeneratorPtr
    @LuaClass
    [
        SameAsNode = UnitFileGenerator
    ]
;

class UnitFileGenerator
    @LuaClass
    [
        ReferenceType = UnitFileGeneratorPtr
    ]
{
    private vector<ElementPtr> elementList;
    private LibraryConfigGenerator libConfig;
    private LibraryTargetPtr library;
    private TargetPtr target;  // So we can keep an ref count on this.
    private UnitTarget & unit;

    public UnitFileGenerator(LibraryTargetPtr library, TargetPtr unit)
    :   libConfig(library),
        library(library),
        target(unit),
        unit(getUnitReference(unit))
    {
        unit->CreateElementList(elementList);
    }

    ~block "cpp"
    {
        MACARONI_SIMPLE_EXCEPTION_DEFINE(UnsetLibraryPtrException,
            "UnitFileGenerator create received a null library.");
        MACARONI_SIMPLE_EXCEPTION_DEFINE(UnsetTargetPtrException,
            "UnitFileGenerator constructor received a null pointer.");
    }

    public static UnitFileGeneratorPtr Create(
        TargetPtr lib, TargetPtr unit)
        @LuaFunction "Create"
    {
        LibraryTarget * lPtr = dynamic_cast<LibraryTarget *>(lib.get());
        if (!lPtr)
        {
            // Accursed Lua glue...
            throw UnsetLibraryPtrException();
        }
        UnitFileGeneratorPtr ptr(new UnitFileGenerator(lPtr, unit));
        return ptr;
    }

    ~hidden static UnitTarget & getUnitReference(TargetPtr t)
    {
        if (!t)
        {
            throw UnsetTargetPtrException();
        }
        return dynamic_cast<UnitTarget &>(*t);
    }

~block "cpp"
{ namespace {

    struct TextVisitor
    :   public BaseVisitor,
        public Visitor<Class>,
        public Visitor<Function>,
        public Visitor<FunctionOverload>,
        public Visitor<Variable>
    {
        CodeText codeText;
        GeneratedFileWriterPtr writer;
        CodeGraph & graph;


        TextVisitor(CodeGraph & graph, GeneratedFileWriterPtr gfw)
        :   graph(graph),
            writer(gfw)
        {
        }

        ~TextVisitor()
        {
        }

        virtual void Visit(Class & e)
        {
            writer->WriteLine("Class ", e.GetNode()->GetFullName());
            codeText = graph.Get(&e, CodeType::Implementation);
        }

        virtual void Visit(Function & e)
        {
            writer->WriteLine("Function ", e.GetNode()->GetFullName());
            codeText = graph.Get(&e, CodeType::Implementation);
        }

        virtual void Visit(FunctionOverload & e)
        {
            writer->WriteLine("FunctionOverload ", e.GetNode()->GetFullName());
            codeText = graph.Get(&e, CodeType::Implementation);
        }

        virtual void Visit(Variable & e)
        {
            writer->WriteLine("Variable ", e.GetNode()->GetFullName());
            codeText.SetElement(&e);
            //codeText.codeType = CodeType::Implementation;

            codeText = graph.Get(&e, CodeType::Implementation);
        }
    };


} } // end cpp block

    ~hidden void printCodeText(GeneratedFileWriterPtr writer,
                               CodeText & ct, int depth=0)
    {
        string pad(depth, ' ');
        if (!ct.GetElement())
        {
            writer->WriteLine(pad, " <NOT INITIALIZED?>");
        }
        else
        {
            writer->WriteLine(pad,
                              ct.GetElement()->GetNode()->GetFullName(),
                              ", ",
                              ct.Type());
            ct.IterateDependencies([&](CodeText & ct){
                printCodeText(writer, ct, depth + 4);
            });
        }
    }

    public void Generate(CodeGraph & graph, PathPtr rootPath)
        @LuaFunction "Generate"
    {
        unit.SetCppFileRootDirectory(rootPath);
        unit.SetHFileRootDirectory(rootPath);

        CodeTextSorter sorter;

        // Go through graph and make sure all the type definitions are
        // available. This will pull in the forward declarations and anything
        // else necessary as well.
        for (auto e : elementList)
        {
            CodeText & ct = graph.Get(e.get(), CodeType::TypeDefinition);
            sorter.Add(&ct);
        }
        vector<CodeText *> headerText = sorter.Sort();
        generateHeader(headerText);

        for (auto e : elementList)
        {
            CodeText & ct = graph.Get(e.get(), CodeType::Implementation);
            sorter.Add(&ct);
        }
        vector<CodeText *> cppText = sorter.Sort();

        // Get rid of dupes. Just leave in nulls to save time.
		for (int i = 0; i < headerText.size(); ++i)
        {
			if (nullptr == headerText[i]) {
				continue;
			}
            for (int j = i; j < cppText.size(); ++ j)
            {
                if (cppText[j] && *headerText[i] == *cppText[j])
                {
                    cppText[j] = nullptr;
                    break;
                }
            }
        }
        generateCpp(headerText, cppText);

    }

    ~hidden void generateCpp(vector<CodeText *> headerText,
                             vector<CodeText *> cppText)
    {
        auto cppWriter = unit.GetCppFile()->CreateFile(true);
        CppFileWriter cpp(libConfig, unit.GetContext()->GetRoot(),
                          cppWriter);

        CodeTextSorter sorter;

        cpp.CppTop(this->unit);

        cpp.CommentHeader("Internal Header");
        cpp.InsertEmptyLine();
        generateHeaderWith(headerText, cpp);

        cpp.InsertEmptyLine();
        cpp.CommentHeader("Additional Dependencies");

        CodeTextProducer producer(cpp);

        // Get the stragglers that aren't in the header but are still used.
        int index = 0;
        for (; index < cppText.size(); ++ index)
        {
            CodeText * ct = cppText[index];
            if (ct)
            {
                if (ct->Type() != CodeType::Implementation)
                {
                    ++ index;
                    break;
                }
                generateText(producer, cpp, *ct);
            }
        }

        int firstImplementationIndex = index;

        // Now bring in the using statements.
        cpp.InsertEmptyLine();
        cpp.CommentHeader("Using Statements");
        auto printUsing = [this, &cpp](CodeText * ct) {
            if (ct && ct->Type() == CodeType::TypeDefinition)
            {
                auto ePtr = ct->GetElement();
                if (ePtr)
                {
                    MACARONI_ASSERT(ePtr->GetNode(), "Node is null, wut?");
                    cpp.UsingStatement(*(ePtr->GetNode()));
                }
            }
        };
        for (CodeText * ct : headerText)
        {
            printUsing(ct);
        }
        for (CodeText * ct : cppText)
        {
            printUsing(ct);
        }

        // Finally, return to print the implementation details.
        cpp.InsertEmptyLine();
        cpp.CommentHeader("Implementation");
        for (index = firstImplementationIndex; index < cppText.size(); ++ index)
        {
            CodeText * ct = cppText[index];
            if (ct && ct->Type() == CodeType::Implementation)
            {
                generateText(producer, cpp, *ct);
            }
        }

        cpp.EnterRootNamespace();
        cpp.CppBottom();
    }

    ~hidden void generateHeader(vector<CodeText *> headerText)
    {
        auto headerWriter = unit.GetHFile()->CreateFile(true);
        CppFileWriter header(libConfig, unit.GetContext()->GetRoot(),
                             headerWriter);
        generateHeaderWith(headerText, header);
    }

    ~hidden void generateHeaderWith(vector<CodeText *> headerText,
                                    CppFileWriter header)
    {
        header.HeaderTop(this->unit);

        CodeTextProducer producer(header);

        for (CodeText * ct : headerText)
        {
            if (ct)
            {
                generateText(producer, header, *ct);
            }
        }
        header.EnterRootNamespace();
        header.HeaderBottom();
    }

    ~hidden void generateText(CodeTextProducer & producer,
                              CppFileWriter & writer,
                              CodeText & ct)
    {
        if (ct.GetElement()->OwnedBy(target))
        {
            producer.Write(ct);
        }
        else
        {
            MACARONI_ASSERT(ct.GetElement(), "Element can't be null.");
            Element * e = const_cast<Element *>(ct.GetElement());
            writer.IncludeFile(*e);
        }
    }

    public string ToString()
        @LuaOperator "__tostring"
    {
        return "UnitGenerator";
    }

    ~hidden void writeHeader()
    {

    }
};
