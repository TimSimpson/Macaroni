~import Macaroni::Core::BaseVisitor;
~import Macaroni::Generators::Cpp::CodeGraph;
~import Macaroni::Generators::Cpp::CodeText;
~import Macaroni::Generators::Cpp::CodeTextProducer;
~import Macaroni::Generators::Cpp::CodeTextSorter;
~import Macaroni::Generators::Cpp::CodeType;
~import Macaroni::Generators::Cpp::CppFileWriter;
~import Macaroni::Model::Cpp::Class;
~import Macaroni::Model::Context;
~import std::cout;
~import Macaroni::Model::Element;
~import Macaroni::Model::ElementPtr;
~import Macaroni::Model::Cpp::Function;
~import Macaroni::Model::Cpp::FunctionOverload;
~import Macaroni::IO::GeneratedFileWriter;
~import Macaroni::IO::GeneratedFileWriterPtr;
~import Macaroni::Lua::LuaClass;
~import Macaroni::Lua::LuaFunction;
~import Macaroni::Lua::LuaOperator;
~import Macaroni::Model::Node;
~import Macaroni::Model::NodePtr;
~import Macaroni::IO::Path;
~import boost::shared_ptr;
~import std::string;
~import Macaroni::Model::Project::Target;
~import Macaroni::Model::Project::TargetPtr;
~import Macaroni::Model::Type;
~import Macaroni::Model::TypePtr;
~import Macaroni::Core::Variable;
~import std::vector;
~import Macaroni::Model::Cpp::Variable;
~import Macaroni::Core::Visitor;



~namespace Macaroni::Generators::Cpp::Unit;


class UnitFileGenerator {};

typedef shared_ptr<UnitFileGenerator> UnitFileGeneratorPtr
    @LuaClass
    [
        SameAsNode = UnitFileGenerator
    ]
;

class UnitFileGenerator
    @LuaClass
    [
        ReferenceType = UnitFileGeneratorPtr
    ]
{
    private vector<ElementPtr> elementList;
    private TargetPtr unit;

    public UnitFileGenerator(TargetPtr unit)
    :   unit(unit)
    {
        // self.libDecl = LibraryDecl ???
        unit->CreateElementList(elementList);
    }

    public static UnitFileGeneratorPtr Create(TargetPtr unit)
        @LuaFunction "Create"
    {
        UnitFileGeneratorPtr ptr(new UnitFileGenerator(unit));
        return ptr;
    }

~block "cpp"
{ namespace {

    struct TextVisitor
    :   public BaseVisitor,
        public Visitor<Class>,
        public Visitor<Function>,
        public Visitor<FunctionOverload>,
        public Visitor<Variable>
    {
        CodeText codeText;
        GeneratedFileWriterPtr writer;
        CodeGraph & graph;


        TextVisitor(CodeGraph & graph, GeneratedFileWriterPtr gfw)
        :   graph(graph),
            writer(gfw)
        {
        }

        ~TextVisitor()
        {
        }

        virtual void Visit(Class & e)
        {
            writer->WriteLine("Class ", e.GetNode()->GetFullName());
            codeText = graph.Get(&e, CodeType::Implementation);
        }

        virtual void Visit(Function & e)
        {
            writer->WriteLine("Function ", e.GetNode()->GetFullName());
            codeText = graph.Get(&e, CodeType::Implementation);
        }

        virtual void Visit(FunctionOverload & e)
        {
            writer->WriteLine("FunctionOverload ", e.GetNode()->GetFullName());
            codeText = graph.Get(&e, CodeType::Implementation);
        }

        virtual void Visit(Variable & e)
        {
            writer->WriteLine("Variable ", e.GetNode()->GetFullName());
            codeText.SetElement(&e);
            //codeText.codeType = CodeType::Implementation;

            codeText = graph.Get(&e, CodeType::Implementation);
        }
    };


} } // end cpp block

    ~hidden void printCodeText(GeneratedFileWriterPtr writer,
                               CodeText & ct, int depth=0)
    {
        string pad(depth, ' ');
        if (!ct.GetElement())
        {
            writer->WriteLine(pad, " <NOT INITIALIZED?>");
        }
        else
        {
            writer->WriteLine(pad,
                              ct.GetElement()->GetNode()->GetFullName(),
                              ", ",
                              ct.Type());
            ct.IterateDependencies([&](CodeText & ct){
                printCodeText(writer, ct, depth + 4);
            });
        }
    }

    public void Generate(CodeGraph & graph, Path & rootPath)
        @LuaFunction "Generate"
    {
        auto p = rootPath.NewPathForceSlash("thing.ufg");
        auto writer = p->CreateFile();

        CodeTextSorter sorter;
        /*TextVisitor visitor(graph, writer);
        for (auto e : elementList)
        {
            writer->WriteLine(e->GetNode()->GetFullName());
            writer->WriteLine("*******************************");
            visitor.codeText = {};
            if (e->Accept(visitor))
            {
                sorter.Add(visitor.codeText);
                writer->WriteLine("    // OK!");
                printCodeText(writer, visitor.codeText);
            }
            else
            {
                writer->WriteLine("    ?!    ~'_'~ < I cannot handle this. )");
            }
            writer->WriteLine();
        }*/

        // Create header
        for (auto e : elementList)
        {
            CodeText & ct = graph.Get(e.get(), CodeType::TypeDefinition);
            sorter.Add(&ct);
        }
        vector<CodeText *> headerText = sorter.Sort();

        CppFileWriter header(unit->GetContext()->GetRoot(), writer);
        CodeTextProducer producer(header);

        for (CodeText * ct : headerText)
        {
            if (ct)
            {
                if (ct->GetElement()->OwnedBy(unit))
                {
                    producer.Write(*ct);
                }
                else
                {
                    MACARONI_ASSERT(ct->GetElement(), "Element can't be null.");
                    Element * e = const_cast<Element *>(ct->GetElement());
                    header.IncludeFile(*e);
                }
                //writer->WriteLine(*ct);
            }
        }
/*
        writer->WriteLine("\n\nIMPLEMENTATION TIME!\n\n");

        for (auto e : elementList)
        {
            CodeText & ct = graph.Get(e.get(), CodeType::Implementation);
            sorter.Add(&ct);
        }
        vector<CodeText *> text2 = sorter.Sort();
        for (CodeText * ct : text2)
        {
            if (ct)
            {
                writer->WriteLine(*ct);
            }
            else
            {
                writer->WriteLine("NULL? WTF?!!!!");
            }
        }*/
    }

    public string ToString()
        @LuaOperator "__tostring"
    {
        return "UnitGenerator";
    }
};
