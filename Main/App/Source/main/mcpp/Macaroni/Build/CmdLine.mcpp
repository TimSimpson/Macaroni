/**
 * Copyright 2011 Tim Simpson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
~import Macaroni::AppPaths;
~import Macaroni::AppPathsPtr;
~import Macaroni::Build::Builder;
~import Macaroni::Build::BuilderArguments;
~import Macaroni::Environment::Console;
~import Macaroni::Model::Context;
~import Macaroni::Model::ContextPtr;
~import Macaroni::Environment::Environment;
~import Macaroni::IO::FileSet;
~import BOOST_FOREACH;
~import Macaroni::Exception;
~import Macaroni::Environment::Input;
~import Macaroni::Environment::InputPtr;
~import Macaroni::Model::Library;
~import Macaroni::Model::LibraryPtr;
~import Macaroni::Environment::LuaEnvironment;
~import Macaroni::Build::Manifest;
~import Macaroni::Build::ManifestPtr;
~import Macaroni::Build::MCompiler;
~import Macaroni::Build::MCompilerOptions;
~import Macaroni::Environment::Messages;
~import Macaroni::Environment::Output;
~import Macaroni::Environment::OutputPtr;
~import boost::optional;
~import Macaroni::IO::Paths;
~import boost::filesystem::path;
~import Macaroni::IO::RegexFileSet;
~import std::string;
~import std::stringstream;
~import std::vector;
~import Macaroni::Containers::VectorOfConstString;

namespace Macaroni::Build {

/** Governs the main execution routine of Macaroni.  The command line
 * has a few options other than just building the project, which
 * are sorted through here.
 */
class CmdLine
{
	private bool about;
	private bool build;
	private bool cavatappiMode;
	private bool clean;
	private string config;
	private Console & console;
	private bool debugMode;
	private bool endPrompt;
	private bool generate;
	private vector<path> generatorPaths;
	private string inputPath;
	private bool install;
	private vector<path> libraryRepoPaths;
	private string luaTestsPath;
	private string manifestPath;
	private optional<path> messagesPath;
	private bool modeM;
	private string outputPath;
	private bool repl;
	private bool saveCppSource;
	private bool startPrompt;
	private bool test;

	public CmdLine(const VectorOfConstString & args, Console & console)
	:	about(false),
	    build(false),
		cavatappiMode(false),
		clean(false),
	    config(""),
		console(console),
		debugMode(false),
		endPrompt(false),
		generate(false),
		generatorPaths(),
		inputPath(""),
		install(false),
		libraryRepoPaths(),
		luaTestsPath(""),
		manifestPath(""),
		messagesPath(),
		modeM(false),
		outputPath(""),
		repl(false),
		saveCppSource(false),
		startPrompt(false),
		test(false)
	{
		for(unsigned int i = 0; i < args.size(); i ++)
		{
			const std::string arg = args[i];
			const std::string nextArg;
			if (i < args.size() - 1) {
				const std::string nextArg = args[i + 1];
				parseArg(arg, nextArg);
			} else {
				parseArg(arg, "");
			}
		}
	}

	public ~CmdLine()
	{
		outputPath = "";
		config = "";
		luaTestsPath = "";
	}


	private bool pathContains(vector<path> & paths, path & path)
	{
		BOOST_FOREACH(const boost::filesystem::path & p, paths)
		{
			if (p == path)
			{
				return true;
			}
		}
		return false;
	}

	private AppPathsPtr createAppPaths()
	{
		if (generatorPaths.size() < 1)
		{
			path gPath = Paths::GetExeDirectoryPath();
			generatorPaths.push_back(gPath / "Generators");
		}
		// Only include exe library path if nothing is specified
		//TODO: Get rid of EXE neighbor library path
		if (libraryRepoPaths.size() < 1)
		{
			path lPath1 = Paths::GetExeDirectoryPath();
			libraryRepoPaths.push_back(lPath1 / "Libraries");
		}
		path lPath2 = Paths::GetUserPath();
		lPath2 = lPath2 / "Libraries";
		if (!pathContains(libraryRepoPaths, lPath2))
		{
			libraryRepoPaths.push_back(lPath2);
		}
		path mPath = !messagesPath
						? Paths::GetExeDirectoryPath()
						: messagesPath.get();
		AppPathsPtr appPaths(new AppPaths(generatorPaths, libraryRepoPaths, mPath));
		return appPaths;
	}

	private void directCompile()
	{
		if (!inputPath.empty() && outputPath.empty())
		{
			console.Write("Missing option outputDirectory.");
		}
		else if (inputPath.empty() && !outputPath.empty())
		{
			console.Write("Missing option inputDirectory.");
		}
		else
		{
			console.Write("Executing compiler directly (no manifest).");
			try
			{
				const std::vector<MACARONI_VE_CONST std::string> generators;
				std::vector<RegexFileSet> input;
				input.push_back(RegexFileSet(boost::filesystem::path(inputPath),
					"\\.mcpp$"));
				MCompilerOptions options(input,
										 boost::filesystem::path(outputPath),
										 generators);
				MCompiler compiler(createAppPaths());
				ContextPtr context(new Context(std::string("%ROOT%")));
				LibraryPtr library = context->FindOrCreateLibrary("", "Command Line", "???");
				compiler.Compile(library, options);
			}
			catch(Macaroni::Exception & ex)
			{
				console.Write("UNHANDLED EXCEPTION:\n");
				console.WriteLine(ex);
			}
		}
	}

	public bool EndPrompt()
	{
		return endPrompt;
	}

	public bool Execute()
	{
		if (about)
		{
			printAboutText();
			return true;
		}
		else if (!luaTestsPath.empty())
		{
			// Runs the unit for Macaroni.
			runLuaTests();
			return true;
		}
		else if (!(inputPath.empty() && outputPath.empty()))
		{
			// Allows someone to not use a manifest.  Not really a great idea for
			// larger projects, but good if someone thinks a the manifest / project
			// layout is overkill (you know, if they're gunshy of using Macaroni).
			directCompile();
			return true;
		}
		else if (repl)
		{
			return runProject(true);
		}
		else if (modeM)
		{
			// Reads project information and runs one or more of the stages
			// of Macaroni's build cycle.
			return runManifest();
		}
		else
		{
			bool success = runProject(false);
			return success;
		}
		return false;
	}

	private void parseArg(const string & arg, const string & next)
	{
		if (arg == "about")
		{
			about = true;
		}
		else if (arg == "cavatappi")
		{
			cavatappiMode = true;
		}
		else if (arg == "configuration")
		{
			if (next.empty())
			{
				config = "";
			}
			else
			{
				config = next;
			}
		}
		else if (arg == "clean")
		{
			clean = true;
		}
		else if (arg == "build")
		{
			build = true;
		}
		else if (arg == "debug")
		{
			debugMode = true;
		}
		else if (arg == "generate")
		{
			generate = true;
		}
		else if (arg == "generatorPath")
		{
			if (next.empty())
			{
				console.Write("No generator path given following \"generatorPath\" arg.");
			}
			else
			{
				generatorPaths.push_back(next);
			}
		}
		else if (arg == "install")
		{
			install = true;
		}
		else if (arg == "libraryRepoPath")
		{
			if (next.empty())
			{
				console.Write("No library repo path given following \"libraryRepoPath\" arg.");
			}
			else
			{
				libraryRepoPaths.push_back(next);
			}
		}
		else if (arg == "luaTests")
		{
			if (next.empty())
			{
				console.Write("No input specified for luaTests command.");
			}
			else
			{
				luaTestsPath = next;
			}
		}
		else if (arg == "inputDirectory")
		{
			if (next.empty())
			{
				console.Write("No input directory given following \"-inputDirectory\" arg.");
			}
			else
			{
				inputPath = next;
			}
		}
		else if (arg == "manifest")
		{
			if (next.empty())
			{
				console.WriteLine("No file given following \"manifest\" arg.");
			}
			else
			{
				manifestPath = next;
			}
		}
		else if (arg == "messagesPath")
		{
			if (next.empty())
			{
				console.Write("No messages path given following "
				              "\"messagesPath\" arg.");
			}
			else
			{
				path p = next;
				messagesPath = optional<path>(p);
				string file = (p / "Messages.txt").string();
				Messages::Init(file.c_str());
			}
		}
		else if (arg == "m" || arg == "modeM")
		{
			modeM = true;
		}
		else if (arg == "outputDirectory")
		{
			if (next.empty())
			{
				console.Write("No output directory given following \"-outputDirectory\" arg.");
			}
			else
			{
				outputPath = next;
			}
		}
		else if (arg == "endPrompt")
		{
			endPrompt = true;
		}
		else if (arg == "repl")
		{
			repl = true;
		}
		else if (arg == "saveCppSource")
        {
            saveCppSource = true;
        }
		else if (arg == "startPrompt")
		{
			startPrompt = true;
		}
		else if (arg == "test")
		{
			test = true;
		}
        else if (arg == "wait")
        {
            std::string stuff;
            std::cin >> stuff;
        }
	}

	private void printAboutText()
	{
		console.WriteLine(
		#include <Macaroni/AboutText.h>
			);
	}

	private void runDefault()
	{
		//WHOA! This using statement made Visual Studio have an internal
		// compiler error.
		//using boost::filesystem::path;
		//optional<boost::filesystem::path> path =
		//	Macaroni::Environment::Environment::FindDefaultProject();
		//if (path) {
		//runProject(true);
		//}
	}

	private void runLuaTests()
	{
		console.WriteLine("Running arbitrary LUA files.");
		Macaroni::Environment::LuaEnvironment lua;
		std::vector<std::string> paths;
		paths.push_back(luaTestsPath);
		paths.push_back(luaTestsPath + "/Generators");
		lua.SetPackageDirectory(paths);

		std::stringstream ss;
		ss << luaTestsPath << "/Tests.lua";
		lua.ParseFile(ss.str());
		lua.Run();
	}

	private bool runManifest()
	{
		if (manifestPath.empty())
		{
			manifestPath = "manifest.lua";
		}
		if (config.empty())
		{
			config = "all";
		}

		/*const Configuration * mConfig = manifest.GetConfiguration(config);
		if (mConfig == nullptr)
		{
			console.Write("Could not find config \"");
			console.Write(config);
			console.Write("\" in manifest.");
			return;
		}
		const Configuration & mRefConfig = *mConfig;*/

		ContextPtr context(new Context("%ROOT%"));
		Builder builder(createAppPaths(), context, console);
		BuilderArguments args(clean, generate, build, test, install, cavatappiMode);
		return builder.Execute(args, manifestPath);
	}

	private bool runProject(bool withRepl)
	{
		// Advance mode - creates an Environment.
		Console * console = new Console(0);
		InputPtr input(console);
		OutputPtr output(console);
		ContextPtr context(new Context("%ROOT%"));
		Macaroni::Environment::Environment env(createAppPaths(), context,
		                                       input, output);
		if (!env.FindDefaultProject())
		{
			output->WriteLine("No project file found, trying to use manifest.");
			return runManifest();
		}
		if (!env.RunDefaultProject() && !withRepl) {
			return false;
		}
		if (withRepl) {
			return env.Repl();
		} else {
			if (clean)
			{
				env.RunCommand("clean();");
			}
			if (generate)
			{
				if (!env.RunCommand("generate();"))
				{
					return false;
				}
			}
			if (build)
			{
				if (!env.RunCommand("build();"))
				{
					return false;
				}
			}
			if (install)
			{
				if (!env.RunCommand("install();"))
				{
					return false;
				}
			}
			return true;
		}
	}

	public inline bool StartPrompt()
	{
		return startPrompt;
	}

} // end class

} // end ns
