/**
 * Copyright 2011 Tim Simpson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
~import Macaroni::AppPaths;
~import Macaroni::AppPathsPtr;
~import Macaroni::Environment::Console;
~import Macaroni::Model::Context;
~import Macaroni::Model::ContextPtr;
~import Macaroni::Environment::Environment;
~import Macaroni::IO::FileSet;
~import BOOST_FOREACH;
~import Macaroni::Exception;
~import Macaroni::Environment::Input;
~import Macaroni::Environment::InputPtr;
~import Macaroni::Model::Library;
~import Macaroni::Model::LibraryPtr;
~import Macaroni::Environment::LuaEnvironment;
~import Macaroni::Environment::Messages;
~import Macaroni::Environment::Output;
~import Macaroni::Environment::OutputPtr;
~import boost::optional;
~import Macaroni::IO::Paths;
~import boost::filesystem::path;
~import Macaroni::IO::RegexFileSet;
~import std::string;
~import std::stringstream;
~import std::vector;
~import Macaroni::Containers::VectorOfConstString;

namespace Macaroni::Build {

/** Governs the main execution routine of Macaroni.  The command line
 * has a few options other than just building the project, which
 * are sorted through here.
 */
class CmdLine
{
	private bool about;
	private bool build;
	private bool clean;
	private Console & console;
	private bool debugMode;
	private bool endPrompt;
	private bool generate;
	private vector<path> generatorPaths;
	private bool install;
	private vector<path> libraryRepoPaths;
	private string luaTestsPath;
	private optional<path> messagesPath;
	private Output * output;
	private bool repl;
	private bool startPrompt;

	public CmdLine(const VectorOfConstString & args, Console & console)
	:	about(false),
	    build(false),
		clean(false),
		console(console),
		debugMode(false),
		endPrompt(false),
		generate(false),
		generatorPaths(),
		install(false),
		libraryRepoPaths(),
		luaTestsPath(""),
		messagesPath(),
		output(&console),
		repl(false),
		startPrompt(false)
	{
		for(unsigned int i = 0; i < args.size(); i ++)
		{
			const std::string arg = args[i];
			const std::string nextArg;
			if (i < args.size() - 1) {
				const std::string nextArg = args[i + 1];
				parseArg(arg, nextArg);
			} else {
				parseArg(arg, "");
			}
		}
	}

	public ~CmdLine()
	{
		luaTestsPath = "";
	}


	private bool pathContains(vector<path> & paths, path & path)
	{
		BOOST_FOREACH(const boost::filesystem::path & p, paths)
		{
			if (p == path)
			{
				return true;
			}
		}
		return false;
	}

	private AppPathsPtr createAppPaths()
	{
		if (generatorPaths.size() < 1)
		{
			path gPath = Paths::GetExeDirectoryPath();
			generatorPaths.push_back(gPath / "Generators");
		}
		// Only include exe library path if nothing is specified
		//TODO: Get rid of EXE neighbor library path
		if (libraryRepoPaths.size() < 1)
		{
			path lPath1 = Paths::GetExeDirectoryPath();
			libraryRepoPaths.push_back(lPath1 / "Libraries");
		}
		path lPath2 = Paths::GetUserPath();
		lPath2 = lPath2 / "Libraries";
		if (!pathContains(libraryRepoPaths, lPath2))
		{
			libraryRepoPaths.push_back(lPath2);
		}
		path mPath = !messagesPath
						? Paths::GetExeDirectoryPath()
						: messagesPath.get();
		AppPathsPtr appPaths(new AppPaths(generatorPaths, libraryRepoPaths, mPath));
		return appPaths;
	}

	public bool EndPrompt()
	{
		return endPrompt;
	}

	public bool Execute()
	{
		if (about)
		{
			printAboutText();
			return true;
		}
		else if (!luaTestsPath.empty())
		{
			// Runs the unit for Macaroni.
			runLuaTests();
			return true;
		}
		else if (repl)
		{
			Messages::Get("Init.Test");
			return runProject(true);
		}
		else
		{
			Messages::Get("Init.Test");
			bool success = runProject(false);
			return success;
		}
		return false;
	}

	private void parseArg(const string & arg, const string & next)
	{
		if (arg == "--about")
		{
			about = true;
		}
		else if (arg == "clean")
		{
			clean = true;
		}
		else if (arg == "build")
		{
			build = true;
		}
		else if (arg == "debug")
		{
			debugMode = true;
		}
		else if (arg == "generate")
		{
			generate = true;
		}
		else if (arg == "--generatorPath")
		{
			if (next.empty())
			{
				output->Write("No generator path given following \"generatorPath\" arg.");
			}
			else
			{
				generatorPaths.push_back(next);
			}
		}
		else if (arg == "install")
		{
			install = true;
		}
		else if (arg == "--libraryRepoPath")
		{
			if (next.empty())
			{
				output->Write("No library repo path given following \"libraryRepoPath\" arg.");
			}
			else
			{
				libraryRepoPaths.push_back(next);
			}
		}
		else if (arg == "luaTests")
		{
			if (next.empty())
			{
				output->Write("No input specified for luaTests command.");
			}
			else
			{
				luaTestsPath = next;
			}
		}
		else if (arg == "--messagesPath")
		{
			if (next.empty())
			{
				output->Write("No messages path given following "
				              "\"messagesPath\" arg.");
			}
			else
			{
				path p = next;
				messagesPath = optional<path>(p);
				string file = (p / "Messages.txt").string();
				Messages::Init(file.c_str());
			}
		}
		else if (arg == "endPrompt")
		{
			endPrompt = true;
		}
		else if (arg == "repl")
		{
			repl = true;
		}
		else if (arg == "startPrompt")
		{
			startPrompt = true;
		}
	}

	~hidden void printAboutText()
	{
		output->WriteLine(
		#include <Macaroni/AboutText.h>
			);
	}

	~hidden void runLuaTests()
	{
		output->WriteLine("Running arbitrary LUA files.");
		Macaroni::Environment::LuaEnvironment lua;
		std::vector<std::string> paths;
		paths.push_back(luaTestsPath);
		paths.push_back(luaTestsPath + "/Generators");
		lua.SetPackageDirectory(paths);

		std::stringstream ss;
		ss << luaTestsPath << "/Tests.lua";
		lua.ParseFile(ss.str());
		lua.Run();
	}

	~hidden bool runProject(bool withRepl)
	{
		Console * console = new Console(0);
		InputPtr input(console);
		OutputPtr output(console);
		ContextPtr context(new Context("%ROOT%"));
		Macaroni::Environment::Environment env(createAppPaths(), context,
		                                       input, output);
		if (!env.FindDefaultProject())
		{
			output->ErrorLine("No project file found.");
			return false;
		}
		if (!env.RunDefaultProject() && !withRepl) {
			return false;
		}
		if (withRepl) {
			return env.Repl();
		} else {
			if (clean)
			{
				env.RunCommand("clean();");
			}
			if (generate)
			{
				if (!env.RunCommand("generate();"))
				{
					return false;
				}
			}
			if (build)
			{
				if (!env.RunCommand("build();"))
				{
					return false;
				}
			}
			if (install)
			{
				if (!env.RunCommand("install();"))
				{
					return false;
				}
			}
			return true;
		}
	}

	public inline bool StartPrompt()
	{
		return startPrompt;
	}

} // end class

} // end ns
