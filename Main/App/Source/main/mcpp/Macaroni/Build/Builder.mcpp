/**
 * Copyright 2011 Tim Simpson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
~import Macaroni::AppPaths;
~import Macaroni::AppPathsPtr;
~import BOOST_FOREACH;
~import Macaroni::Build::BuilderArguments;
~import Macaroni::Build::BuilderArgumentsPtr;
~import Macaroni::Build::BuildContextPtr;
~import Macaroni::Environment::Console;
~import Macaroni::Model::Context;
~import Macaroni::Model::ContextPtr;
~import Macaroni::Build::Cpp::CppFile;
~import boost::filesystem::create_directories;
~import Macaroni::Exception;
~import Macaroni::IO::FileSet;
~import Macaroni::IO::GeneratedFileWriter;
~import Macaroni::Build::GeneratorContext;
~import Macaroni::Build::InstallContext;
~import Macaroni::Build::InstallContextPtr;
~import boost::lexical_cast;
~import Macaroni::Model::Library;
~import Macaroni::Build::LibraryId;
~import Macaroni::Model::LibraryPtr;
~import Macaroni::Environment::LuaEnvironment;
~import Macaroni::Build::Manifest;
~import Macaroni::Build::ManifestPtr;
~import Macaroni::Build::ManifestOrganizer;
~import Macaroni::Build::MCompiler;
~import Macaroni::Build::MCompilerOptions;
~import boost::optional;
~import Macaroni::Parser::ParserException;
~import boost::filesystem::path;
~import Macaroni::IO::Path;
~import Macaroni::IO::PathPtr;
~import Macaroni::IO::Paths;
~import Macaroni::Environment::Process;
~import boost::shared_ptr;
~import Macaroni::Model::Source;
~import std::string;
~import Macaroni::Environment::StringPair;
~import std::stringstream;
~import system;
~import std::vector;
~import Macaroni::Containers::VectorOfConstString;

~import nullptr; // Including so that <Macaroni/ME.h> is included. :(

namespace Macaroni::Build {

/* Governs the main execution routine of Macaroni.
	 * Options:
	 * 	generate - Call "generate" function of manifest.  This
	 *  is where the generation of extra information in the AST or C++ source
	 *  code occurs.
	 *  build - After "generate" phase, call build routines.  These are utility
	 *  functions for building the project through Macaroni.
	 *  install - Copy resources
*/
class Builder
{
	private AppPathsPtr appPaths;
	private vector<CppFile> cppFiles;
	private VectorOfConstString cppSrcRoots;
	//private path manifestPath;
	private MCompiler compiler;
	private const Console & console;
	private ContextPtr context;
	private bool initialized;
	private string properties;

	public Builder(AppPathsPtr appPaths, ContextPtr context, Console & console)
	:	appPaths(appPaths),
		compiler(appPaths), // WARNING: This is only initialized after appPaths due to order of declaration!
		console(console),
		context(context),
		initialized(false),
		//library(),//GetName(), manifest->GetVersion())),
		//manifest(),
		//manifestPath(manifestPath),
		properties()
	{
	}

	public bool Clean(ManifestPtr manifest)
	{
		path outputPath = manifest->GetMOutput();
		console.Write("~ Destroying directory ");
		console.WriteLine(outputPath.string());
		boost::filesystem::remove_all(outputPath);
		return true;
	}

	/** From whatever manifest we've opened with, recursively look for a parent.
	 * End when the parent has been returned. */
	private path climbToTop(vector<path> & manifests, path manifestPath)
	{
		manifests.push_back(manifestPath);
		path p = boost::filesystem::system_complete(manifestPath);
		if (p.has_parent_path())
		{
			path mp = p.parent_path().parent_path() / "manifest.lua";
			if (boost::filesystem::exists(mp))
			{
				return climbToTop(manifests, mp);
			}
		}
		return manifestPath;
	}


	BuildContextPtr createBuildContext(ManifestPtr manifest, LibraryPtr library)
	{
		//const Path dir(manifest->GetRootDirectory(),
		//			   manifest->GetRootDirectory());
		vector<PathPtr> sources;
		BOOST_FOREACH(const std::string & srcDirectory, manifest->GetMSource())
		{
			path sd(srcDirectory);
			PathPtr newPath(new Path(sd)); //manifest->GetRootDirectory() / srcDirectory));
			sources.push_back(newPath);
		}
		path od(manifest->GetMOutput());
		PathPtr genSrc(new Path(od)); //manifest->GetRootDirectory() / manifest->GetMOutput()));
		path installPath = getInstallPath(manifest->GetId());
		PathPtr installPathPtr(new Path(installPath, installPath));
		BuildContextPtr iCon(new BuildContext(appPaths, library, sources, genSrc, installPathPtr, properties));
		return iCon;
	}

	private LibraryPtr createLibraryForManifest(ManifestPtr manifest, bool isInstalled)
	{
		optional<path> installPath;
		if (isInstalled)
		{
			installPath = manifest->GetManifestFile().branch_path();
		}
		LibraryPtr newL(context->FindOrCreateLibrary(installPath, manifest->GetId()));
		return newL;
	}

	///*public bool CreateInterface()
	//{
	//	return CreateInterfaceMh();
	//}

	//public bool CreateInterfaceMh()
	//{
	//	return true;
	//}*/

	//TO-DO : Change "test" to "build".
	public bool Execute(const BuilderArguments & arguments, string manifestPath)
	{
		boost::filesystem::path p;
		p = manifestPath;
		return Execute(arguments, p);
	}

	public bool Execute(const BuilderArguments & arguments, path manifestPath)
	{
		LibraryPtr library;
		ManifestPtr manifest;
		if (!initialized)
		{
			if (!Init(arguments, manifestPath, manifest, library))
			{
				console.WriteLine("An unrecoverable error occured in the initialization phase.");
				return false;
			}
		}
		return execute(arguments, manifest, library);
	}

	private bool execute(const BuilderArguments & arguments,
						 const ManifestPtr manifest,
						 const LibraryPtr library)
	{
		console.WriteLine("--------------------------------------------------------------------------------");
		console.Write("    ");
		console.WriteLine(manifest->GetName());
		console.WriteLine("--------------------------------------------------------------------------------");

		if (manifest->ContainsCavatappi() && !arguments.CavatappiMode())
		{
			return executeCavatappi(arguments, manifest, library, false);
		}
		else
		{
			return executeNormal(arguments, manifest, library);
		}
	}

	private bool executeCavatappi(const BuilderArguments & arguments,
								  const ManifestPtr manifest,
								  const LibraryPtr library,
								  const bool forceNewProcess)
	{
		console.WriteLine("~~ Invoking Cavatappi...");
		//TODO: Uninstall artifacts from repo
		if (library->IsInstalled())
		{
			if (!Uninstall(library))
			{
				console.WriteLine("~ Cannot uninstall library. Will not call Cavatappi.");
				return false;
			}
		}

		std::stringstream cmd;
		cmd << "cavatappi install manifest "
			<< manifest->GetManifestFile().string();
		system(cmd.str().c_str());

		UpdateInstallStatus(library);


		return library->IsInstalled();
		//vector<const string> paths;
		//vector<StringPair> envVars;
		//boost::optional<path> empty;
		//Process process(empty,  // process
		//				"cavatappi install",	  // args
		//				manifest->GetManifestFile().branch_path(), // working dir
		//				paths,
		//				envVars);
		//bool success = process.Run(console);
		//return success;
	}

	private bool executeNormal(const BuilderArguments & arguments,
							   const ManifestPtr manifest,
							   const LibraryPtr library)
	{
		PathPtr genSrc(new Path(manifest->GetMOutput(), manifest->GetMOutput()));
		genSrc->CreateDirectory();

		bool success = parseChildren(arguments, manifest, library)
			&& parseBugs(arguments, manifest, library);

		if (success && arguments.Clean())
		{
			success = Clean(manifest);
		}
		if (success && arguments.Generate())
		{
			success = ParseMacaroniSource(arguments, manifest, library);
			if (success)
			{
				BuildContextPtr iCon = createBuildContext(manifest, library);
				success = manifest->RunTarget(console, iCon, "generate", "Generate")->Success;
			}
		}

		if (success && arguments.Build())
		{

			BuildContextPtr iCon = createBuildContext(manifest, library);//new BuildContext(library, src, genSrc, installPathPtr));
			success = manifest->RunTarget(console, iCon, "build", "Build")->Success;
		}
		if (success && arguments.Test())
		{
			BuildContextPtr iCon = createBuildContext(manifest, library);//new BuildContext(library, src, genSrc, installPathPtr));
			success = manifest->RunTarget(console, iCon, "test", "Test")->Success;
		}

		if (success && arguments.Install())
		{
			success = Install(manifest, library);
		}

		if (success)
		{
			console.WriteLine("~ Success!");
		}
		else
		{
			console.WriteLine("~ Failure  ");
		}
		return success;
	}

	private path getInstallPath(const LibraryId & id)
	{
		path userPath(Paths::GetUserPath());
		return userPath / "Libraries" / id.GetGroup()
						/ id.GetName() / id.GetVersion();
	}

	/** Runs init.lua in Macaroni user directory to establish base
	 * settings, then initializes manifest and prepares all
	 * found dependencies.
	 */
	public bool Init(const BuilderArguments & arguments,
					 path manifestPath,
					 ManifestPtr & manifest,
					 LibraryPtr  & library)
	{
		initialized = true;
		properties = RunInitialScript();
		vector<path> manifests;
		path topParent = climbToTop(manifests, manifestPath);
		ManifestPtr upperManifest;
		for (int i = manifests.size() - 1; i >= 0; i --)
		{
			loadManifest(arguments, upperManifest, manifests[i], false, manifest, library);
			properties = manifest->GetProperties();
			if (!parseManifest(arguments, manifest, library))
			{
				return false;
			}
			upperManifest = manifest;
		}
		return true;
		// Finally, the manifest and library of whatever we're working on is loaded.
		// Now, get a list of the children...

	//	/*struct Resolve : public LocalManifestResolver
	//	{
	//		virtual optional<LibraryId> FindParent(const optional<string &> & parentPath)
	//		{
	//			bool mustExist = false;
	//			path filePath;
	//			if (!parentPath)
	//			{
	//				filePath = manifestPath.branch_path();
	//			}
	//			else
	//			{
	//				filePath = manifestPath / (parentPath.get());
	//				mustExist = true;
	//			}
	//			if (!boost::filesystem::exists(filePath))
	//			{
	//				if (mustExist)
	//				{
	//					stringstream ss;
	//					ss	<< "Could not find parent manifest of \""
	//						<< manifestPath << "\" given the path \""
	//						<< parentPath << "\".";
	//					throw Exception(ss.str().c_str());
	//				}
	//				return optional<LibraryId>();
	//			}

	//		}
	//
	//		virtual LibraryId FindChild(const std::string & childPath) = 0;

	//		virtual void SelfLibraryId(const LibraryId & myId) = 0;
	//	};		*/
	}

	public bool Install(ManifestPtr manifest, LibraryPtr library)
	{
		path installPath = getInstallPath(manifest->GetId());
		if (boost::filesystem::exists(installPath))
		{
			boost::filesystem::remove_all(installPath);
		}
		else
		{
			boost::filesystem::create_directories(installPath);
		}

		// Interface.mh - copy this file to root of directory.
		path localMhInterface(manifest->GetRootDirectory());
		localMhInterface = localMhInterface / manifest->GetMOutput();
		localMhInterface = localMhInterface / "Interface.mh";
		//path exportMhInterfaceDir(installPath);
		//exportMhInterfaceDir = exportMhInterfaceDir;
		//boost::filesystem::create_directories(exportMhInterfaceDir);
		//path exportMhInterface = exportMhInterfaceDir/ "Interface.mh";
		//boost::filesystem::copy_file(localMhInterface, exportMhInterface);

		//const Path dir(manifest->GetRootDirectory(), manifest->GetRootDirectory());
		//PathPtr genSrc = dir.NewPathForceSlash(manifest->GetMOutput());//"/GeneratedSource");
		//PathPtr src(new Path(manifest->GetRootDirectory(), manifest->GetRootDirectory()));
		//PathPtr installPathPtr(new Path(installPath, installPath));
		BuildContextPtr iCon = createBuildContext(manifest, library); //(new BuildContext(library, src, genSrc, installPathPtr));
		Manifest::RunResultPtr result = manifest->RunTarget(console, iCon, "install", "Install");
		//Path::CopyDirectoryContents(headersLocal, headersInstall);
		// return true;
		if (result->Success)
		{
			manifest->SaveAs(installPath / "manifest-final.lua", result->RunList);
			optional<path> ip(installPath);
			library->SetInstallPath(ip);
		}
		return result->Success;
	}

	/** Loads a manifest, which is to say it opens up the Manifest file,
	 * creates a library, and opens all dependencies, running their prepare
	 * phases.  Does not load children.  Returns the new properties setting
	 * based on reading the manifest. */
	private void loadManifest(const BuilderArguments & arguments,
							  ManifestPtr upperManifest,
							  path manifestPath, bool isInstalled,
							  ManifestPtr & outManifest,
							  LibraryPtr & outLibrary)
	{
		ManifestPtr newM(new Manifest(manifestPath, properties, upperManifest, arguments.CavatappiMode()));
		outManifest = newM;
		outLibrary = createLibraryForManifest(outManifest, isInstalled);
	}

	///*private void parseChildren(vector<LibraryId> & dependencyStack,
	//						   ManifestPtr sourceManifest,
	//						   LibraryPtr sourceLibrary)
	//{
	//	const std::vector<const std::string> children = sourceManifest->GetChildren();
	//	BOOST_FOREACH(const string & child, children)
	//	{
	//
	//		std::vector<FileSet> input;
	//		input.push_back(FileSet(boost::filesystem::path(child), "\\.m(cpp|h)?$"));
	//		compiler.BuildModel(sourceLibrary, input);
	//	}
	//}*/

	/////** Parse a list of manifests almost like you're parsing Children,
	//// * but instead invoke Cavatappi. */
	////private bool parseCavatappi(GeneratedFileWriter & writer,
	////						    const ManifestPtr manifest,
	////						    const LibraryPtr library)
	////{
	////	writer.WriteLine("-- Cavatappi Success Report");
	////	writer.WriteLine("");
	////	writer.WriteLine("count="
	////		+ lexical_cast<string>(manifest->GetCavatappiManifests().size())
	////		+ ";");
	////	writer.WriteLine("results = {");
	////	BOOST_FOREACH(const string & directory, manifest->GetCavatappiManifests())
	////	{
	////		path cavatappiManifest(manifest->GetRootDirectory());
	////		//TODO: Uninstall each manifest from the repo!
	////	}

	////	BOOST_FOREACH(const string & directory, manifest->GetCavatappiManifests())
	////	{
	////		path cavatappiManifest(manifest->GetRootDirectory());
	////		cavatappiManifest = cavatappiManifest / directory / "manifest.lua";
	////		bool success = invokeCavatappi(cavatappiManifest);
	////		if (!success)
	////		{
	////			writer.WriteLine("\t{
	////		}
	////		//writer.WriteLine("\t{");
	////		//writer.WriteLine("\t\tid={group=" +
	////		//writer.WriteLine("\t}");

	////		ManifestPtr childManifest(new Manifest(childPath, properties));
	////		childManifests.push_back(childManifest);
	////	}
	////	writer.WriteLine("}; -- end of results");
	////}

	/////** Invokes cavatappi to completely build whatever is here.
	//// *  We can confirm cavatappi's success by checking to see if the
	//// *  artifacts exist in the repo. */
	////private bool invokeCavatappi(const path & manifestPath)
	////{
	////	// TODO: Invoke, and if exit code suggests failure uninstall repo
	////	// artifacts just to be safe.
	////}

	public bool parseBugs(const BuilderArguments & arguments,
						  const ManifestPtr manifest,
						  const LibraryPtr library)
	{
		std::vector<ManifestPtr> bugsManifests;
		BOOST_FOREACH(const string & bugDir, manifest->GetBugs())
		{
			path bugPath(manifest->GetRootDirectory());
			bugPath = bugPath / bugDir / "manifest.lua";
			ManifestPtr bugManifest;
			LibraryPtr bugLibrary;
			boost::optional<std::string> desc;
			manifest->SetBugResult(bugDir, bugLibrary, desc);
			try
			{
				// Always claim we aren't Cavatappi.
				// That way, if the bug is to show an issue with the manifest
				// loading process, they can use the Cavatappi mechanism to
				// put the library credentials in the first part and the buggy
				// part in the second manifest file.
				bugManifest.reset(new Manifest(bugPath, properties, manifest, false));
			}
			catch(...)
			{
				console.Write("An error occurred simply parsing the bug manifest \"");
				console.Write(bugPath.string());
				console.WriteLine("\".");
				continue;
			}
			createLibraryForManifest(bugManifest, false);
			bugLibrary = context->FindLibrary(bugManifest->GetId());
			// Don't care about return value.
			executeCavatappi(arguments, bugManifest, bugLibrary, true);
			desc = bugManifest->GetDescription();
			manifest->SetBugResult(bugDir, bugLibrary, desc);
		}
		return true;
	}

	public bool parseChildren(const BuilderArguments & arguments,
							  const ManifestPtr manifest,
							  const LibraryPtr library)
	{
		std::vector<ManifestPtr> childManifests;
		BOOST_FOREACH(const string & child, manifest->GetChildren())
		{
			path childPath(manifest->GetRootDirectory());
			childPath = childPath / child / "manifest.lua";
			ManifestPtr childManifest(new Manifest(childPath, properties,
												   manifest, arguments.CavatappiMode()));
			childManifests.push_back(childManifest);
		}
		ManifestOrganizer list(childManifests);
		list.Sort();
		BOOST_FOREACH(ManifestPtr manifest, childManifests)
		{
			// Create libraries so that the final-manifest will not be searched.
			createLibraryForManifest(manifest, false);
		}
		BOOST_FOREACH(ManifestPtr childManifest, childManifests)
		{
			LibraryPtr library = context->FindLibrary(childManifest->GetId());
			parseManifest(arguments, childManifest, library);
			if (!execute(arguments, childManifest, library))
			{
				return false;
			}
		}
		return true;
	}

	/////** Reads and consumes all dependencies of *this* manifest, including
	//// * Macaroni source.  May also invoke "prepare" phases of final-manifests. */
	////public bool ParseDependencies()
	////{
	////	return parseManifest(manifest, library);
	////}

	/** Parse the dependencies of the given manifest / library. */
	private void parseDependencies(const BuilderArguments & arguments,
		                           vector<LibraryId> & dependencyStack,
								   ManifestPtr sourceManifest,
								   LibraryPtr sourceLibrary)
	{
		BOOST_FOREACH(const LibraryId id, sourceManifest->GetDependencies())
		{
			dependencyStack.push_back(id);
			parseDependency(arguments, dependencyStack, sourceManifest,
							sourceLibrary, id);
			dependencyStack.pop_back();
		}
	}

	private void parseDependency(const BuilderArguments & arguments,
								 vector<LibraryId> & dependencyStack,
								 ManifestPtr sourceManifest,
								 LibraryPtr sourceLibrary,
								 const LibraryId dependencyId)
	{
		LibraryPtr existingLib = sourceLibrary->GetContext()->FindLibrary(dependencyId);
		if (!existingLib)
		{
			// Load manifest of dependency, create libraries
			path manifestFilePath = appPaths->FindFinalManifestFile(dependencyId);
			ManifestPtr none;
			ManifestPtr dManifest(new Manifest(manifestFilePath, properties,
											   none,
											   arguments.CavatappiMode()));
			const boost::optional<boost::filesystem::path> installPath(
				appPaths->FindInstallPath(dependencyId));
			LibraryPtr dLib = sourceLibrary->GetContext()->FindOrCreateLibrary(installPath, dependencyId);
			// Now parse all of the dependency's dependencies before continuing.
			parseDependencies(arguments, dependencyStack, dManifest, dLib);
			// Now add all dependencies to library

			// Parse all of its source.
			parseManifestSource(arguments, dManifest, dLib);

			// Run prepare phase of dependency
			BuildContextPtr iCon = createBuildContext(dManifest, dLib);
			iCon->GetOutputDir()->CreateDirectory();
			//TODO: Don't really care if this fails.  But it probably shouldn't
			// print a message to the console.
			Manifest::RunResultPtr result = dManifest->RunTarget(console, iCon, "prepare", "Prepare");

			// Now, add it as a dependency of this library.
			sourceLibrary->AddDependency(dLib.get());
			existingLib = dLib;
		}
		sourceLibrary->AddDependency(existingLib);
	}

	public bool ParseMacaroniSource(const BuilderArguments & arguments,
									ManifestPtr manifest, LibraryPtr library)
	{
		console.WriteLine("~ Creating Macaroni model from source files (.mh, .mcpp). ~");
		try
		{
			parseManifestSource(arguments, manifest, library);
			return true;
		}
		catch(Macaroni::Parser::ParserException & pe)
		{
			console.Write("An error occurred parsing Macaroni source files.");
			console.WriteLine(pe.GetSource()->ToString());
			console.WriteLine(pe.GetMessage());
			return false;
		}
		catch(Macaroni::Exception & ex)
		{
			console.Write("An error occurred parsing Macaroni source files.");
			console.WriteLine(ex.GetSource());
			console.WriteLine(ex.GetMessage());
			return false;
		}		
	}

	public bool parseManifest(const BuilderArguments & arguments,
							  ManifestPtr & manifest, LibraryPtr & library)
	{
		vector<LibraryId> dependencyStack;
		dependencyStack.push_back(manifest->GetId());
		try
		{
			///*stringstream ss;
			//ss << "~ Parsing dependencies for {[["
			//	<< library->GetGroup()
			//	<< "]], [[" << library->GetName()
			//	<< "]], [[" << library->GetVersion()
			//	<< "]]}";
			//console.WriteLine(ss.str().c_str());*/
			parseDependencies(arguments, dependencyStack, manifest, library);
			//parseNestedLibraries(dependencyStack, manifest, library);
			//console.WriteLine("~ Creating Macaroni model from source files (.mh, .mcpp). ~");
			//parseManifestSource(manifest, library);
		}
				catch(Macaroni::Parser::ParserException & pe)
		{
			console.Write("An error occurred parsing Macaroni code while in dependency ");
			printOutDependencyStack(dependencyStack);
			console.WriteLine(".");
			console.WriteLine(pe.GetSource()->ToString());
			console.WriteLine(pe.GetMessage());
			return false;
		}
		catch(Macaroni::Exception & ex)
		{
			console.Write("An error occurred in ");
			printOutDependencyStack(dependencyStack);
			console.WriteLine(".");
			console.WriteLine(ex.GetSource());
			console.WriteLine(ex.GetMessage());
			return false;
		}
		catch(std::exception & ex)
		{
			console.Write("An error occurred in ");
			printOutDependencyStack(dependencyStack);
			console.WriteLine(".");
			console.WriteLine(ex.what());
			return false;
		}
		return true;
	/*



		std::string mSrc = manifest->GetMSource()[0];
		std::string mOut = manifest->GetMOutput();
		std::vector<FileSet> inputFiles;

		// Include dependencies
		BOOST_FOREACH(ManifestPtr dependency, manifest->GetDependencies())
		{
			parseDependency(library, compiler, dependency);
		}
		// end include dependencies

		inputFiles.push_back(FileSet(boost::filesystem::path(mSrc), "\\.mcpp$"));

		std::vector<const std::string> blankGeneratorSelection;
		MCompilerOptions options(inputFiles,
								 boost::filesystem::path(mOut),
								 blankGeneratorSelection);

		try
		{
			compiler.Compile(library, options);
		}
		catch(Macaroni::Exception & ex)
		{
			console.WriteLine("An error occurred during Macaroni phase.");
			console.WriteLine(ex.GetSource());
			console.WriteLine(ex.GetMessage());
			return false;
		}
		catch(Macaroni::Parser::ParserException & pe)
		{
			console.WriteLine("Error parsing Macaroni code: ");
			console.WriteLine(pe.GetSource()->ToString());
			console.WriteLine(pe.GetMessage());
			return false;
		}
		return true;*/
	}

	/** Given the manifest and library, add its Macaroni source to the Context.
	 */
	private void parseManifestSource(const BuilderArguments & arguments,
									 ManifestPtr sourceManifest,
									 LibraryPtr sourceLibrary)
	{
		const std::vector<MACARONI_VE_CONST std::string> src = sourceManifest->GetMSource();
		BOOST_FOREACH(const string & dir, src)
		{
			std::vector<FileSet> input;
			input.push_back(FileSet(boost::filesystem::path(dir), "\\.m(cpp|h)?$"));
			compiler.BuildModel(sourceLibrary, input);
		}
	}

	private void parseNestedLibraries(vector<LibraryId> & dependencyStack,
									  ManifestPtr sourceManifest,
									  LibraryPtr sourceLibrary)
	{
		///*BOOST_FOREACH(const string & childDir, sourceManifest->GetChildren())
		//{

		//}*/
	}

	private void printOutDependencyStack(vector<LibraryId> & dependencyStack)
	{
		bool seenOne = false;
		BOOST_FOREACH(LibraryId & id, dependencyStack)
		{
			if (!seenOne)
			{
				seenOne = true;
			}
			else
			{
				console.Write(" -> ");
			}
			console.Write(id.GetGroup());
			console.Write("|");
			console.Write(id.GetName());
			console.Write("|");
			console.Write(id.GetVersion());
		}
	}

	/** The initial script is where system-wide settings are stored. */
	public string RunInitialScript()
	{
		path userPath(Paths::GetUserPath());
		path initLuaPath = userPath / "init.lua";
		if (!boost::filesystem::exists(initLuaPath))
		{
			stringstream ss;
			ss	<< "Could not find init.lua at "
				<< initLuaPath
				<< ".";
			console.WriteLine(ss.str());
			return "{}";
		}
		else
		{
			LuaEnvironment env;
			env.ParseFile(initLuaPath.string());
			env.Run();
			stringstream cereal;
			env.SerializeTable(cereal, "properties");
			return cereal.str();
		}
	}

	///*public bool SaveCppSource()
	//{
	//	createCppSrcRoots();
 //       createCppFileList();

	//	path cppSourceLocal(manifest->GetCppSourceOutput());

	//	std::stringstream ss;
	//	ss << "Saving generated and non-generated C++ source code to " <<
	//			cppSourceLocal.string() << ".";
	//	console.WriteLine(ss.str());

	//	boost::filesystem::create_directories(cppSourceLocal);
	//	CopyHeaderFiles(cppSourceLocal);
	//	CopyCppFiles(cppSourceLocal);
	//	return true;
	//}*/
	/** Tries to uninstall artifacts. */
	public bool Uninstall(LibraryPtr library)
	{
		PathPtr installPath = library->FindInstallPath();
		if (!!installPath)
		{
			stringstream ss;
			ss << "~ Uninstalling library from \""
			   << installPath->GetAbsolutePath() << "\"...";
			console.WriteLine(ss.str());
			installPath->ClearDirectoryContents();
			if (!!installPath)
			{
				console.WriteLine("\t...failed to uninstall!");
				return false;
			}
		}
		return true;
	}

	public void UpdateInstallStatus(LibraryPtr library)
	{
		PathPtr installPath = library->FindInstallPath();
		if (!installPath)
		{
			// look for it
			path p = getInstallPath(library->GetId());
			if (boost::filesystem::exists(p / "manifest-final.lua"))
			{
				optional<path> op(p);
				library->SetInstallPath(op);
			}
		}
		else
		{
			if (installPath->NewPathForceSlash("manifest-final.lua")->Exists())
			{
				return;
			}
			// Somehow, the final manifest has dissappeared.
			optional<path> none;
			library->SetInstallPath(none);
		}
	}

};

} // end namespace

