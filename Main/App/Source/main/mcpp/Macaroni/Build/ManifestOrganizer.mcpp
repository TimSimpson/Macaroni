~import BOOST_FOREACH;
~import Macaroni::Exception;
~import Macaroni::Model::Library;
~import Macaroni::Build::LibraryId;
~import Macaroni::Model::LibraryPtr;
~import Macaroni::Build::Manifest;
~import Macaroni::Build::ManifestPtr;
~import boost::shared_ptr;
~import std::string;
~import std::stringstream;
~import std::vector;

namespace Macaroni::Build {


/** TODO:!!!!!!!!!!!!!!!!
 * I am *POSTIVE* there are bugs in this code and that this should be a 
 * topographical sort. 
 */
class ManifestOrganizer
{	
	private vector<ManifestPtr> & list;
	private vector<vector<LibraryId>> listHistory; // Stores history of swaps

	public ManifestOrganizer(vector<ManifestPtr> & manifests)
	:	list(manifests),
		listHistory()
	{ 
		listHistory.reserve(list.size());
		for (unsigned int i = 0; i < list.size(); i ++)
		{
			//const LibraryId & libI = list[i]->GetId();
			listHistory.push_back(vector<LibraryId>());
			//listHistory[i].push_back(libI);
		}
	}

	private void clearHistory()
	{
		// I used to think the history of every move should always be
		// preserved.  Then I noticed that really, I only care about the history
		// within a single move, just to ensure things aren't infinitely 
		// swapping.
		BOOST_FOREACH(vector<LibraryId> & history, listHistory)
		{
			history.clear();
		}
	}

	private bool dependencyListContains(
		const std::vector<LibraryId> & dependencies, const LibraryId & id)
	{
		BOOST_FOREACH(const LibraryId & dep, dependencies)
		{
			if (dep == id)
			{
				return true;
			}
		}
		return false;
	}
	
	public vector<ManifestPtr> GetList()
	{
		return list;
	}

	private bool positionPreviouslyContainedId(const int position, const LibraryId & id)
	{
		vector<LibraryId> & history = listHistory.at(position);
		BOOST_FOREACH(const LibraryId & lib, history)
		{
			if (lib == id)
			{
				return true;
			}
		}	
		return false;
	}
	
	private void set(int position, ManifestPtr manifest)
	{
		if ((unsigned)position >= list.size())// || position < 0) 
		{
			stringstream ss;
			ss << "Set for position " << position << " is not valid.";
			throw Exception(ss.str().c_str());
		}
		//const LibraryId & libId = manifest->GetId();		
		list[position] = manifest;
		listHistory[position].push_back(manifest->GetId());	
	}

	public void Sort()
	{		
		for (unsigned int i = 0; i < list.size(); i ++)
		{
			clearHistory();
			ManifestPtr iM = list[i];			
			for (unsigned int j = i + 1; j < list.size(); j ++)
			{
				if (dependencyListContains(iM->GetDependencies(), 
										   list[j]->GetId()))
				{
					if (swap(i, j))
					{
						i --; // redo I with its new value
						break;
					} // If swap fails, just proceed.
				}		
			}
		}
	}

	/** Does not allow a sweap to occur if a manifest with the same id
	 * was already stored there. 
	 * Returns true if the set works, false if the set was denied. */
	private bool swap(int a, int b)
	{
		if (a >= b)
		{
			std::stringstream ss;
			ss	<< "A can't be more than B. A = " << a 
				<< " and B = " << b << ".";
			throw Exception(ss.str().c_str());
		}

		const LibraryId & libB = list.at(b)->GetId();
		// Do not swap if we have done this before...
		if (positionPreviouslyContainedId(a, libB))
		{
			return false;
		}
		ManifestPtr mA = list.at(a);
		ManifestPtr mB = list.at(b);
		set(a, mB);
		set(b, mA);
		return true;
	}
	
};

} // end namespace

