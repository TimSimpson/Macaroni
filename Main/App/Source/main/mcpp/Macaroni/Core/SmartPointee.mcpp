~import boost::intrusive_ptr;
~import boost::optional;


~namespace Macaroni::Core;


/** A class capable of polymorphically handling an intrusive pointer by 
 *  returning a function pointer of how to destroy the resource.
 *  Koenig look-up is faster of course but this works better when the 
 *  intrusive_ptr is of a super class and we want to choose the policy at 
 *  runtime. */
class SmartPointee
{
	class Finalizer { ~hfile=<Macaroni/Core/SmartPointee.h> }; // Sigh...
	
	~block "h"
	{
	public:
	/** A function pointer to something which will handle cleaning this up.*/
	typedef void (*Finalizer)(SmartPointee * ptr);
	} // end h block

	/** Called when a smart pointer adds a reference. */
	public virtual void AddReference();	

	public ~global ~friend void intrusive_ptr_add_ref(SmartPointee * p)
	{
		p->AddReference();
	}

	public ~global ~friend void intrusive_ptr_release(SmartPointee * p)
	{
		optional<SmartPointee::Finalizer> finalizer = p->RemoveReference();
		if (finalizer)
		{
			SmartPointee::Finalizer & f = finalizer.get();
			(*f)(p);
		}
	}

	/** Removes a reference. If the reference count is zero, the return value
	 *  is a method which will delete the reference. */
	public virtual optional<SmartPointee::Finalizer> RemoveReference();
};

