/**
 * Copyright 2011 Tim Simpson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

~import Macaroni::AppPaths;
~import Macaroni::AppPathsPtr;
//~import Macaroni::Environment::Values::AnyPtr;
~import BOOST_FOREACH;
~import Macaroni::Model::Context;
~import Macaroni::Model::ContextLuaMetaData;
~import Macaroni::Model::ContextPtr;
~import Macaroni::Model::Element;
~import Macaroni::Exception;
~import Macaroni::IO::FileNotFoundException;
~import boost::format;
~import Macaroni::Environment::Input;
~import Macaroni::Environment::InputPtr;
~import boost::optional;
~import Macaroni::Environment::Output;
~import Macaroni::Environment::OutputLuaMetaData;
~import Macaroni::Environment::OutputPtr;
~import Macaroni::Environment::LuaEnvironment;
~import Macaroni::Model::NodePtr;
~import boost::filesystem::path;
~import Macaroni::IO::Paths;
~import Macaroni::Environment::PluginFactory;
~import Macaroni::Environment::PluginFactoryLuaMetaData;
~import Macaroni::Environment::PluginFactoryPtr;
~import Macaroni::Model::Project::ProjectVersionId;
~import Macaroni::Model::Project::ProjectVersion;
~import Macaroni::Model::Project::ProjectVersionLuaMetaData;
~import Macaroni::Model::Project::ProjectVersionPtr;
~import Macaroni::Model::Reason;
~import Macaroni::Environment::ReplCommand;
~import std::string;

// There's a bug which prevents Macaroni from detecting creating a node within
// a Namespace if the node has the same short name. :(

class Macaroni::Environment::Environment
/*
 * Handles the interactive portions of a context, particularly regarding
 * the project / build system.
 */
{
	~block "h-predef" {
		#include <boost/algorithm/string.hpp>
		#include <Macaroni/Environment/PluginFactory.h>
	}

	~block "cpp"
	{
		MACARONI_SIMPLE_STRING_EXCEPTION_DEFINE(LoadProjectException,
			"Error parsing the definition file for project %s.");

		MACARONI_SIMPLE_STRING_EXCEPTION_DEFINE(LoadProjectException2,
			"After running the project definition file, project %s was "
			"still undefined, meaning the definition file is incorrect.");

		MACARONI_SIMPLE_STRING_EXCEPTION_DEFINE(ProjectNotFoundException,
			"Could not find a file for project %s.");
		
	}

	private AppPathsPtr appPaths;
	private ContextPtr context;
	private InputPtr input;
	private LuaEnvironment luaEnvironment;
	private OutputPtr output;
	private PluginFactoryPtr pluginFactory;
	private bool quitRepl;
	private path workingDirectory;

	public Environment(AppPathsPtr appPaths, ContextPtr context,
		               InputPtr input, OutputPtr output)
	: appPaths(appPaths),
	  context(context),
	  input(input),
	  luaEnvironment(),
	  output(output),
	  pluginFactory(new PluginFactory(appPaths)),
	  quitRepl(false),
	  workingDirectory("./")
	{
		output->WriteLine("Creating new Environment with the following "
		                  "AppPaths:");
		output->Write(format("Message file : %s") %
		           appPaths->GetMessagePaths().string());
		output->WriteLine("");
		output->Write("Library Paths : [");
		BOOST_FOREACH(const boost::filesystem::path & path,
			          appPaths->GetLibraryRepoPaths())
		{
			output->Write(path.string());
		}
		output->WriteLine("]");
		output->Write("Generator Paths : [");
		BOOST_FOREACH(const boost::filesystem::path & path,
			          appPaths->GetGeneratorPaths())
		{
			output->Write(path.string());
		}
		output->WriteLine("]");
		output->WriteLine("Opening internal modules...");
		luaEnvironment.OpenAllLuaModules();
		output->WriteLine("");

		// Insert the output global variable first, since the following two 
		// scripts may need it.
		OutputLuaMetaData::PutInstanceOnStack(luaEnvironment.GetState(),
		                                      output);
		lua_setglobal(luaEnvironment.GetState(), "output");
		
		// Run "project-init.lua" which has helper functions.
		runProjectInitScript();

		// Run "init.lua" which resides in the user directory.
		runInitScript();

		// Insert our global variables: context, output, plugins, and load.
		
		ContextLuaMetaData::PutInstanceOnStack(luaEnvironment.GetState(),
		                                       context);
		lua_setglobal(luaEnvironment.GetState(), "context");		
		
		PluginFactoryLuaMetaData::PutInstanceOnStack(luaEnvironment.GetState(), 
													 pluginFactory);
		lua_setglobal(luaEnvironment.GetState(), "plugins");

		// The load function is a closue, with *this* instances as user data.
		// Its ok to do that since this instance owns the Lua state, so the
		// function will only be called while it exists.
		lua_pushlightuserdata(luaEnvironment.GetState(), (void *) this);
		lua_pushcclosure(luaEnvironment.GetState(), LoadProjectLua, 1);
		lua_setglobal(luaEnvironment.GetState(), "load");

		lua_pushlightuserdata(luaEnvironment.GetState(), (void *) this);
		lua_pushcclosure(luaEnvironment.GetState(), getWorkingDirectoryLua, 1);
		lua_setglobal(luaEnvironment.GetState(), "getWorkingDirectory");

	}

	~hidden bool exit(string line)
		@ReplCommand [
			Name = "~exit",
			Summary = "Exit REPL."
		]
	{
		quitRepl = true;
		return true;
	}

	///** Creates a file set relative to the local directory. */
	//public FileSetPtr Files(const string & localPath, optional<string> regEx)
	//{
	//	path p = this->workingDirectory / path;
	//	if (regEx) 
	//	{
	//		FileSetPtr ptr(new FileSet(p, regEx));
	//		return ptr;
	//	} else {
	//		FileSetPtr ptr(new FileSet(p, regEx));
	//		return ptr;
	//	}
	//}
	
	/* Finds any file named "project.lua" in the current directory or any
	 * directory it can find by iterating downward. */
	public static optional<path> FindDefaultProject()
	{
		path defaultLua = "project.lua";
		if (boost::filesystem::exists(defaultLua)) {
			return optional<path>(defaultLua);
		}
		path directory = "../";
		while(boost::filesystem::exists(directory)) {
			path file = directory / "project.lua";
			if (boost::filesystem::exists(file)) {
				return optional<path>(file);
			}
			directory = directory / "../";
		}
		return boost::none;
	}

	public inline ContextPtr GetContext()
	{
		return context;
	}

	public inline LuaEnvironment & GetLuaEnvironment()
	{
		return luaEnvironment;
	}	

	~hidden static int getWorkingDirectoryLua(lua_State * L)
	{
		void * uv1 = lua_touserdata(L, lua_upvalueindex(1));
		Environment * me = static_cast<Environment *>(uv1);
		lua_pushstring(L, me->workingDirectory.string().c_str());
		return 1;
	}

	/////** Grabs a global variable from the Lua Environment. */
	////public AnyPtr GrabGlobal(const string & name) const
	////{
	////	lua_getglobal(luaEnvironment, name.c_str());
	////	AnyPtr rtn = LuaEnvironment::SerializeValue(luaEnvironment, -1, name);
	////	lua_pop(luaEnvironment, 1);
	////	return rtn;
	////}	

	~hidden static int LoadProjectLua(lua_State * L)
	{
		void * uv1 = lua_touserdata(L, lua_upvalueindex(1));
		Environment * me = static_cast<Environment *>(uv1);
		ProjectVersionId id(luaL_checkstring(L, 1), luaL_checkstring(L, 2),
			                luaL_checkstring(L, 3));
		try
		{
			ProjectVersionPtr pv = me->LoadProject(id);
			ProjectVersionLuaMetaData::PutInstanceOnStack(L, pv);
			return 1;
		} catch(const Exception & ex) {
			return luaL_error(L, ex.message().c_str());
		} catch(const std::exception & ex) {
			return luaL_error(L, ex.what());
		}		
	}

	public ProjectVersionPtr LoadProject(const ProjectVersionId & pv)
	{
		Environment seperateEnv(appPaths, context, input, output);
		if (!seperateEnv.RunProject(pv))
		{
			throw LoadProjectException(pv.ToString().c_str(),
				                       MACARONI_INTERNAL_SOURCE);
		}
		/*
		AnyPtr anyPtr = seperateEnv.GrabGlobal("project");
		Any * any = anyPtr.get();
		Macaroni_Model_Project_ProjectVersion * pvAny 
			= dynamic_cast<Macaroni_Model_Project_ProjectVersion *>(any);
		if (pvAny)
		{
			return pvAny->Get();			
		}
		else
		{			
			throw LoadProjectException2(pv.ToString());
		}*/
		ProjectVersionPtr result = context->FindProjectVersion(pv);
		if (!result)
		{
			throw LoadProjectException2(pv.ToString().c_str(),
				                        MACARONI_INTERNAL_SOURCE);
		}
		return result;
	}

	~hidden bool maccy(string line)
		@ReplCommand[
			Name = "~",
			Summary = "Who is justice?"
		]
	{
		output->WriteLine("");
		output->WriteLine("           ~'o'~");
		output->WriteLine("           \\___/");
		output->WriteLine("");
		output->WriteLine("             ^");
        output->WriteLine("      ( I AM JUSTICE! )");
        output->WriteLine("");
		return true;
	}

	~hidden bool pwd(string line)
		@ReplCommand [
			Name = "~pwd",
			Summary = "Print working directory."
		]
	{
		output->WriteLine(this->workingDirectory.string());
		return true;
	}


	public bool Repl()
	{
		output->WriteLine("Starting Lua REPL. Type \"~help\" for commands.");
		string line;
		quitRepl = false;
		while(!quitRepl)
		{
			input->ReadString(line);
			if (line == "~quit" || line=="~exit")
			{
				return true;
			}
			else if (!replCommand(line))
			{
				try
				{
					luaEnvironment.ParseString("REPL", line.c_str());
				} catch(const Macaroni::Exception & me) {
					output->WriteLine(format("Error parsing : %s")
					                  % me.message());
				}
				try
				{
					luaEnvironment.Run();
				} catch(const Macaroni::Exception & me) {
					output->WriteLine(format("Error running Lua : %s")
					                  % me.message());
				}
			}
		}
	}

	~hidden bool replCommand(string line);

	public bool RunDefaultProject() 
	{
		optional<path> projectFilePath = FindDefaultProject();
		if (projectFilePath) {
			return RunProject(projectFilePath.get());
		} else {
			output->WriteLine("No \"project.lua\" file found.");
			return false;
		}
	}

	~hidden void runInitScript()
	{
		path userPath(Paths::GetUserPath());
		path initLuaPath = userPath / "init.lua";
		if (!boost::filesystem::exists(initLuaPath))
		{
			output->ErrorLine(str(format("Could not find init.lua at %s.") 
				              % initLuaPath.string()));
			luaEnvironment.ParseString("init.lua", "properties = {}");
			luaEnvironment.Run();
		}
		else
		{
			output->WriteLine(format("Running %s...") % initLuaPath.string());
			luaEnvironment.ParseFile(initLuaPath.string());
			luaEnvironment.Run();
		}
	}		

	public bool RunProject(const ProjectVersionId & pv)
	{
		optional<path> projectFilePath = appPaths->FindFinalProjectFile(pv);
		if (projectFilePath)
		{
			return RunProject(projectFilePath.get());
		}
		else
		{
			throw ProjectNotFoundException(pv.ToString().c_str(),
				                           MACARONI_INTERNAL_SOURCE);
		}
	}

	~hidden void runProjectInitScript()
	{
		optional<path> pInitDir = appPaths->FindFinalProjectDirectory(
			ProjectVersionId("Macaroni", "Project-Lua", "0"));
		if (!pInitDir)
		{
			output->ErrorLine("Could not open project "
				"Macaroni / Project-Lua / 0! Project system may be unusable.");
			return;
		}
		else
		{
			path projectInit = pInitDir.get() / "src/project-init.lua";
			if (!boost::filesystem::exists(projectInit))
			{
				output->ErrorLine(str(format("Could not find project-init.lua "
					" at %s.") % projectInit.string()));
				return;
			}
			output->WriteLine(format("Running %s...") % projectInit.string());
			luaEnvironment.ParseFile(projectInit.string());
			luaEnvironment.Run();
		}
	}

	public bool RunProject(path projectFilePath)
	{
		if (!boost::filesystem::exists(projectFilePath))
		{
			throw FileNotFoundException(projectFilePath.string());
		}
		this->workingDirectory = projectFilePath;
		this->workingDirectory.remove_leaf();
		string filePath = projectFilePath.string();
		output->WriteLine(format("Parsing file %s...") % filePath);
		try
		{
			luaEnvironment.ParseFile(filePath);
			luaEnvironment.Run();
		} catch(const Macaroni::Exception & me) {
			output->WriteLine(me.message());
			return false;
		}			
		return true;
	}

	///*~hidden bool setDirectory(string line)
	//	@ReplCommand[
	//		Name = "~cd",
	//		Summary = "Change working directory."
	//	]
	//{
	//	string newDir = line.substr(3, line.size() - 3);
	//	path p(newDir);
	//	appPaths->SetWorkingDirectory(p);
	//	std::vector<std::string> paths;
	//	paths.push_back(appPaths->GetWorkingDirectory().string());
	//	BOOST_FOREACH(path gp, appPaths->GetGeneratorPaths()) {
	//		paths.push_back(gp.string());
	//	}
	//	luaEnvironment.SetPackageDirectory(paths);
	//	return true;
	//}*/

	~hidden bool showHelp(string line)
		@ReplCommand[
			Name = "~help",
			Summary = "Print help."
		]
	;
};
